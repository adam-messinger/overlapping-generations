<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Futures: 2025-2100</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .chart-container {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
        }
        .metric-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #4cc9f0;
        }
        .metric-detail {
            font-size: 12px;
            color: #666;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: right;
        }
        th {
            background: #0f3460;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        tr:nth-child(even) {
            background: #1a1a3e;
        }
        tr:hover {
            background: #1f4068;
        }
        .crossover-highlight {
            background: #2d6a4f !important;
        }
        .controls {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-label {
            font-size: 13px;
            color: #888;
            margin-bottom: 8px;
            display: block;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
        }
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            color: #4cc9f0;
        }
        .insights {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .insight-item {
            padding: 10px 0;
            border-bottom: 1px solid #0f3460;
        }
        .insight-item:last-child {
            border-bottom: none;
        }
        .insight-year {
            color: #4cc9f0;
            font-weight: 600;
        }
        .legend-custom {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>Energy Futures: 2025-2100</h1>
    <p class="subtitle">Phase 2: Demographics module with population projections and dependency ratios</p>

    <div class="metrics-grid">
        <div class="metric-card">
            <div class="metric-label">Solar Crosses Gas</div>
            <div class="metric-value" id="solar-gas-cross">--</div>
            <div class="metric-detail">Year when solar LCOE &lt; gas LCOE</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Solar+Battery Crosses Gas</div>
            <div class="metric-value" id="solar-battery-gas-cross">--</div>
            <div class="metric-detail">Dispatchable clean energy milestone</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Coal Uneconomic</div>
            <div class="metric-value" id="coal-uneconomic">--</div>
            <div class="metric-detail">Year coal LCOE &gt; cheapest clean</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Battery Cost 2035</div>
            <div class="metric-value" id="battery-2035">--</div>
            <div class="metric-detail">$/kWh storage cost</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Global Pop Peak</div>
            <div class="metric-value" id="pop-peak">--</div>
            <div class="metric-detail">Year population peaks</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Global Dependency 2075</div>
            <div class="metric-value" id="dependency-2075">--</div>
            <div class="metric-detail">Old-age dependency ratio</div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label class="control-label">Carbon Price ($/ton CO₂)</label>
            <div class="slider-container">
                <input type="range" id="carbon-price" min="0" max="200" value="50" step="10">
                <span class="slider-value" id="carbon-price-value">$50</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Solar Learning Rate (α)</label>
            <div class="slider-container">
                <input type="range" id="solar-alpha" min="0.10" max="0.30" value="0.20" step="0.01">
                <span class="slider-value" id="solar-alpha-value">0.20</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Solar Capacity Growth Rate (%/year)</label>
            <div class="slider-container">
                <input type="range" id="solar-growth" min="5" max="30" value="20" step="1">
                <span class="slider-value" id="solar-growth-value">20%</span>
            </div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Levelized Cost of Energy (LCOE) Trajectories</div>
        <canvas id="lcoe-chart"></canvas>
        <div class="legend-custom" id="chart-legend"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Battery Storage Cost Trajectory</div>
        <canvas id="battery-chart"></canvas>
    </div>

    <div class="insights">
        <div class="chart-title">Key Crossover Events</div>
        <div id="crossover-events"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Global Population by Region (Billions)</div>
        <canvas id="population-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Old-Age Dependency Ratio by Region</div>
        <canvas id="dependency-chart"></canvas>
    </div>

    <table id="era-table">
        <thead>
            <tr>
                <th>Era</th>
                <th>Solar</th>
                <th>Wind</th>
                <th>Gas</th>
                <th>Coal</th>
                <th>Nuclear</th>
                <th>Battery</th>
                <th>Solar+Batt</th>
                <th>Dependency</th>
            </tr>
        </thead>
        <tbody id="era-tbody"></tbody>
    </table>

    <div class="controls" style="text-align: center;">
        <button id="export-csv" style="background: #4cc9f0; color: #000; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 600;">Export Demographics CSV</button>
    </div>

    <script>
    // =============================================================================
    // PRIMITIVES - Core mathematical functions
    // =============================================================================

    /**
     * Compound growth: start × (1 + rate)^years
     */
    function compound(start, rate, years) {
        return start * Math.pow(1 + rate, years);
    }

    /**
     * Wright's Law learning curve: cost = cost₀ × cumulative^(-α)
     * As cumulative production doubles, cost falls by 2^(-α)
     * α=0.20 means 13% cost reduction per doubling (1 - 2^-0.2 ≈ 0.13)
     */
    function learningCurve(cost0, cumulative, alpha) {
        if (cumulative <= 0) return cost0;
        return cost0 * Math.pow(cumulative, -alpha);
    }

    /**
     * EROEI depletion: EROEI declines as resources are extracted
     * EROEI(t) = EROEI₀ × (remaining/initial)^β
     * Net energy = gross × (1 - 1/EROEI)
     */
    function depletion(reserves, extracted, eroei0, beta = 0.5) {
        const remaining = Math.max(reserves - extracted, 0.01);
        const fractionRemaining = remaining / reserves;
        const eroei = eroei0 * Math.pow(fractionRemaining, beta);
        return {
            eroei: Math.max(eroei, 1.1), // EROEI can't go below ~1
            netEnergyFraction: 1 - 1 / Math.max(eroei, 1.1),
            remaining
        };
    }

    /**
     * Logistic S-curve: models adoption/deployment
     * Returns value between 0 and ceiling
     */
    function logistic(start, ceiling, rate, years) {
        const k = rate;
        const midpoint = Math.log((ceiling - start) / start) / k;
        return ceiling / (1 + Math.exp(-k * (years - midpoint)));
    }

    /**
     * Poisson shock probability: P(at least one event) = 1 - e^(-λ)
     */
    function poissonShock(lambda, magnitude) {
        const prob = 1 - Math.exp(-lambda);
        return { probability: prob, magnitude };
    }

    // =============================================================================
    // ENERGY SOURCES - Parameters and cost models
    // =============================================================================

    const energySources = {
        solar: {
            name: 'Solar PV',
            cost0: 50,           // $/MWh in 2025
            alpha: 0.20,         // Learning rate
            capacity2025: 1500,  // GW installed globally
            growthRate: 0.20,    // 20% annual capacity growth
            carbonIntensity: 0,  // kg CO₂/MWh
            color: '#ffd60a'
        },
        wind: {
            name: 'Wind',
            cost0: 45,
            alpha: 0.10,         // Slower learning (more mature)
            capacity2025: 1000,
            growthRate: 0.12,
            carbonIntensity: 0,
            color: '#4cc9f0'
        },
        gas: {
            name: 'Natural Gas',
            cost0: 40,
            eroei0: 30,          // Starting EROEI
            reserves: 200,       // Arbitrary units
            extractionRate: 2,   // Units per year
            carbonIntensity: 400,// kg CO₂/MWh
            color: '#f77f00'
        },
        coal: {
            name: 'Coal',
            cost0: 35,
            eroei0: 25,
            reserves: 500,
            extractionRate: 3,
            carbonIntensity: 900,
            color: '#6c757d'
        },
        nuclear: {
            name: 'Nuclear',
            cost0: 90,
            alpha: 0.0,          // No learning (regulatory/political stagnation)
            capacity2025: 400,
            growthRate: 0.02,
            carbonIntensity: 0,
            color: '#9d4edd'
        },
        battery: {
            name: 'Battery Storage',
            cost0: 150,          // $/kWh in 2025
            alpha: 0.18,
            capacity2025: 100,   // GWh
            growthRate: 0.35,    // Rapid growth
            color: '#06d6a0'
        }
    };

    // =============================================================================
    // DEMOGRAPHICS - Fernández-Villaverde-informed population model
    // =============================================================================

    /**
     * Regional demographic parameters (2025 baseline)
     * Key insight: Global TFR already below replacement (~2.17 vs 2.21)
     * All regions converging toward low fertility faster than expected
     */
    const demographics = {
        oecd: {
            name: 'OECD',
            pop2025: 1.4e9,           // 1.4 billion
            fertility: 1.6,           // TFR (below replacement)
            fertilityFloor: 1.4,      // Long-term convergence target
            fertilityDecay: 0.005,    // Annual convergence rate
            lifeExpectancy: 82,
            young: 0.18,              // 0-19 share
            working: 0.59,            // 20-64 share
            old: 0.23,                // 65+ share (high, aging societies)
            migrationRate: 0.003,     // net immigration (helps offset aging)
            color: '#4cc9f0'
        },
        china: {
            name: 'China',
            pop2025: 1.4e9,
            fertility: 1.05,          // Very low TFR (lower than reported due to measurement issues)
            fertilityFloor: 0.85,     // Could go very low (South Korea at 0.7)
            fertilityDecay: 0.012,    // Faster decline
            lifeExpectancy: 78,
            young: 0.16,              // Already shrinking
            working: 0.68,            // Still large working-age cohort
            old: 0.16,                // Rising fast
            migrationRate: 0.0,
            color: '#f94144'
        },
        em: {  // Emerging Markets (India, Brazil, Indonesia, etc.)
            name: 'Emerging Markets',
            pop2025: 3.5e9,
            fertility: 2.1,           // Near replacement
            fertilityFloor: 1.4,      // Converging faster than expected
            fertilityDecay: 0.02,     // Faster convergence (Colombia at 1.06!)
            lifeExpectancy: 72,
            young: 0.27,
            working: 0.63,
            old: 0.10,                // Still relatively young
            migrationRate: -0.001,
            color: '#90be6d'
        },
        row: {  // Rest of World (Africa, etc.)
            name: 'Rest of World',
            pop2025: 2.0e9,
            fertility: 3.5,           // Still high but falling fast
            fertilityFloor: 1.6,      // Even Africa converging
            fertilityDecay: 0.03,     // Fast decline (Fernández-Villaverde: converging faster than expected)
            lifeExpectancy: 65,
            young: 0.40,              // Very young population
            working: 0.54,
            old: 0.06,
            migrationRate: -0.001,
            color: '#f9c74f'
        }
    };

    /**
     * Project fertility rate with convergence to floor
     * TFR(t) = TFR_floor + (TFR_0 - TFR_floor) × e^(-decay × t)
     */
    function projectFertility(tfr0, floor, decay, years) {
        return floor + (tfr0 - floor) * Math.exp(-decay * years);
    }

    /**
     * Calculate crude birth rate from TFR
     * CBR ≈ TFR × (women of childbearing age 15-49 as fraction of pop) / average age span
     * Calibrated to produce ~18 births per 1000 globally in 2025
     */
    function birthRateFromTFR(tfr, workingShare, youngShare) {
        // Women 15-49 are roughly split between young (15-19) and working (20-49) cohorts
        // Approximate: 0.25 of young + 0.65 of working are women 15-49
        const womenOfChildbearingAge = youngShare * 0.25 + workingShare * 0.65;
        // Divide by 2 (only women) and by 32 (average childbearing span)
        return (tfr * womenOfChildbearingAge * 0.5) / 32;
    }

    /**
     * Calculate crude death rate based on age structure and life expectancy
     * CDR ≈ 1/LE adjusted for age structure
     * Calibrated to produce ~8 deaths per 1000 globally in 2025
     */
    function deathRate(youngShare, workingShare, oldShare, lifeExpectancy) {
        // Age-specific mortality rates (approximate)
        // Young: very low mortality, Working: low mortality, Old: moderate (people live long in old cohort)
        const youngMortality = 0.001;  // 0.1% per year
        const workingMortality = 0.003; // 0.3% per year
        // Remaining life expectancy at 65 is about LE - 65 + 10 (selection effects)
        const remainingLEat65 = Math.max(15, lifeExpectancy - 55);
        const oldMortality = 1 / remainingLEat65;

        return youngShare * youngMortality +
               workingShare * workingMortality +
               oldShare * oldMortality;
    }

    /**
     * Age cohorts forward by one year
     * 3-cohort model: Young (0-19), Working (20-64), Old (65+)
     * Calibrated for realistic population dynamics
     */
    function ageCohorts(region, tfr, year) {
        const { young, working, old, migrationRate, lifeExpectancy } = region;
        const pop = region.population;

        // Calculate births and deaths using improved formulas
        const births = birthRateFromTFR(tfr, working, young) * pop;
        const deaths = deathRate(young, working, old, lifeExpectancy) * pop;

        // Aging transitions
        // Young cohort: 20 years, so 1/20 age out per year
        // Working cohort: 45 years (20-64), so 1/45 age out per year
        const agingOutOfYoung = (young * pop) / 20;
        const agingOutOfWorking = (working * pop) / 45;

        // Deaths by cohort (proportional to mortality rates)
        const youngDeaths = young * pop * 0.001;
        const workingDeaths = working * pop * 0.002;
        const oldDeaths = deaths - youngDeaths - workingDeaths;

        // New cohort sizes
        const newYoung = Math.max(0, young * pop + births - agingOutOfYoung - youngDeaths);
        const newWorking = Math.max(0, working * pop + agingOutOfYoung - agingOutOfWorking - workingDeaths);
        const newOld = Math.max(0, old * pop + agingOutOfWorking - Math.max(0, oldDeaths));

        // Apply migration (to working-age primarily)
        const migration = pop * migrationRate;
        const adjustedWorking = newWorking + migration * 0.8;
        const adjustedYoung = newYoung + migration * 0.15;
        const adjustedOld = newOld + migration * 0.05;

        const newPop = adjustedYoung + adjustedWorking + adjustedOld;

        return {
            population: newPop,
            young: adjustedYoung / newPop,
            working: adjustedWorking / newPop,
            old: adjustedOld / newPop,
            youngAbs: adjustedYoung,
            workingAbs: adjustedWorking,
            oldAbs: adjustedOld
        };
    }

    /**
     * Run full demographics simulation for 2025-2100
     * Returns yearly data by region and global aggregates
     */
    function runDemographics() {
        const years = [];
        const regions = {
            oecd: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            china: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            em: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            row: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] }
        };
        const global = { population: [], young: [], working: [], old: [], dependency: [] };

        // Initialize current state for each region
        const currentState = {};
        for (const [key, params] of Object.entries(demographics)) {
            currentState[key] = {
                population: params.pop2025,
                young: params.young,
                working: params.working,
                old: params.old,
                lifeExpectancy: params.lifeExpectancy,
                migrationRate: params.migrationRate
            };
        }

        for (let year = 2025; year <= 2100; year++) {
            const t = year - 2025;
            years.push(year);

            let globalPop = 0, globalYoung = 0, globalWorking = 0, globalOld = 0;

            for (const [key, params] of Object.entries(demographics)) {
                // Project fertility for this year
                const tfr = projectFertility(params.fertility, params.fertilityFloor, params.fertilityDecay, t);
                regions[key].fertility.push(tfr);

                // Store current values
                const state = currentState[key];
                regions[key].population.push(state.population);
                regions[key].young.push(state.young * state.population);
                regions[key].working.push(state.working * state.population);
                regions[key].old.push(state.old * state.population);
                regions[key].dependency.push(state.old / state.working);

                // Accumulate global totals
                globalPop += state.population;
                globalYoung += state.young * state.population;
                globalWorking += state.working * state.population;
                globalOld += state.old * state.population;

                // Age forward for next year (except last year)
                if (year < 2100) {
                    const nextState = ageCohorts(state, tfr, year);
                    currentState[key] = {
                        ...nextState,
                        lifeExpectancy: params.lifeExpectancy + t * 0.1, // Slow improvement
                        migrationRate: params.migrationRate
                    };
                }
            }

            // Store global aggregates
            global.population.push(globalPop);
            global.young.push(globalYoung);
            global.working.push(globalWorking);
            global.old.push(globalOld);
            global.dependency.push(globalOld / globalWorking);
        }

        return { years, regions, global };
    }

    /**
     * Find year of peak population
     */
    function findPopulationPeak(populationArray, years) {
        let maxPop = 0;
        let peakYear = years[0];
        for (let i = 0; i < populationArray.length; i++) {
            if (populationArray[i] > maxPop) {
                maxPop = populationArray[i];
                peakYear = years[i];
            }
        }
        return { year: peakYear, population: maxPop };
    }

    /**
     * Export demographics data as CSV
     */
    function exportDemographicsCSV(demographicsData) {
        const { years, regions, global } = demographicsData;
        let csv = 'Year,Region,Population,Young,Working,Old,TFR,Dependency\n';

        for (let i = 0; i < years.length; i++) {
            const year = years[i];

            for (const [key, data] of Object.entries(regions)) {
                csv += `${year},${demographics[key].name},${data.population[i].toFixed(0)},${data.young[i].toFixed(0)},${data.working[i].toFixed(0)},${data.old[i].toFixed(0)},${data.fertility[i].toFixed(2)},${(data.dependency[i] * 100).toFixed(1)}%\n`;
            }

            csv += `${year},Global,${global.population[i].toFixed(0)},${global.young[i].toFixed(0)},${global.working[i].toFixed(0)},${global.old[i].toFixed(0)},,${(global.dependency[i] * 100).toFixed(1)}%\n`;
        }

        return csv;
    }

    // =============================================================================
    // SIMULATION ENGINE
    // =============================================================================

    function runSimulation(params = {}) {
        const carbonPrice = params.carbonPrice ?? 50;
        const solarAlpha = params.solarAlpha ?? 0.20;
        const solarGrowth = params.solarGrowth ?? 0.20;

        const years = [];
        const results = {
            solar: [],
            wind: [],
            gas: [],
            coal: [],
            nuclear: [],
            battery: [],
            solarPlusBattery: []
        };

        // Track cumulative extraction for fossil fuels
        let gasExtracted = 0;
        let coalExtracted = 0;

        for (let year = 2025; year <= 2100; year++) {
            const t = year - 2025;
            years.push(year);

            // Solar: learning curve with configurable parameters
            const solarCapacity = energySources.solar.capacity2025 * Math.pow(1 + solarGrowth, t);
            const solarCumulative = solarCapacity / energySources.solar.capacity2025;
            const solarLCOE = learningCurve(energySources.solar.cost0, solarCumulative, solarAlpha);
            results.solar.push(solarLCOE);

            // Wind: learning curve
            const windCapacity = energySources.wind.capacity2025 * Math.pow(1 + energySources.wind.growthRate, t);
            const windCumulative = windCapacity / energySources.wind.capacity2025;
            const windLCOE = learningCurve(energySources.wind.cost0, windCumulative, energySources.wind.alpha);
            results.wind.push(windLCOE);

            // Gas: EROEI depletion + carbon price
            gasExtracted += energySources.gas.extractionRate;
            const gasDepletion = depletion(
                energySources.gas.reserves,
                gasExtracted,
                energySources.gas.eroei0
            );
            // Cost rises as EROEI falls (need more energy input per output)
            const gasBaseCost = energySources.gas.cost0 * (energySources.gas.eroei0 / gasDepletion.eroei);
            const gasCarbonCost = (energySources.gas.carbonIntensity / 1000) * carbonPrice;
            results.gas.push(gasBaseCost + gasCarbonCost);

            // Coal: EROEI depletion + carbon price
            coalExtracted += energySources.coal.extractionRate;
            const coalDepletion = depletion(
                energySources.coal.reserves,
                coalExtracted,
                energySources.coal.eroei0
            );
            const coalBaseCost = energySources.coal.cost0 * (energySources.coal.eroei0 / coalDepletion.eroei);
            const coalCarbonCost = (energySources.coal.carbonIntensity / 1000) * carbonPrice;
            results.coal.push(coalBaseCost + coalCarbonCost);

            // Nuclear: essentially flat (no learning in current environment)
            const nuclearCapacity = energySources.nuclear.capacity2025 * Math.pow(1 + energySources.nuclear.growthRate, t);
            const nuclearCumulative = nuclearCapacity / energySources.nuclear.capacity2025;
            const nuclearLCOE = learningCurve(energySources.nuclear.cost0, nuclearCumulative, energySources.nuclear.alpha);
            results.nuclear.push(nuclearLCOE);

            // Battery: learning curve (cost per kWh)
            const batteryCapacity = energySources.battery.capacity2025 * Math.pow(1 + energySources.battery.growthRate, t);
            const batteryCumulative = batteryCapacity / energySources.battery.capacity2025;
            const batteryCost = learningCurve(energySources.battery.cost0, batteryCumulative, energySources.battery.alpha);
            results.battery.push(batteryCost);

            // Solar + Battery: combined cost for dispatchable clean energy
            // Assume 4 hours of storage needed, battery cycles 365 times/year for 15 years
            const batteryLCOE = (batteryCost * 4) / (365 * 15); // $/kWh storage → $/MWh contribution
            results.solarPlusBattery.push(solarLCOE + batteryLCOE * 1000); // Convert to $/MWh
        }

        // Run demographics simulation
        const demographicsData = runDemographics();

        return { years, results, demographics: demographicsData };
    }

    function findCrossovers(years, results) {
        const crossovers = [];

        // Solar crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.solar[i] < results.gas[i] && results.solar[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Solar LCOE falls below Gas',
                    detail: `Solar: $${results.solar[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Solar+Battery crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.solarPlusBattery[i] < results.gas[i] && results.solarPlusBattery[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Solar+Battery beats Gas (dispatchable clean)',
                    detail: `Solar+Batt: $${results.solarPlusBattery[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Coal becomes uneconomic (more expensive than cheapest clean)
        for (let i = 1; i < years.length; i++) {
            const cheapestClean = Math.min(results.solar[i], results.wind[i]);
            const cheapestCleanPrev = Math.min(results.solar[i-1], results.wind[i-1]);
            if (results.coal[i] > cheapestClean && results.coal[i-1] <= cheapestCleanPrev) {
                crossovers.push({
                    year: years[i],
                    event: 'Coal becomes more expensive than cheapest clean',
                    detail: `Coal: $${results.coal[i].toFixed(0)}/MWh vs Clean: $${cheapestClean.toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Wind crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.wind[i] < results.gas[i] && results.wind[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Wind LCOE falls below Gas',
                    detail: `Wind: $${results.wind[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        return crossovers;
    }

    // =============================================================================
    // VISUALIZATION
    // =============================================================================

    let lcoeChart = null;
    let batteryChart = null;
    let populationChart = null;
    let dependencyChart = null;
    let currentDemographicsData = null;

    function updateCharts() {
        const carbonPrice = parseFloat(document.getElementById('carbon-price').value);
        const solarAlpha = parseFloat(document.getElementById('solar-alpha').value);
        const solarGrowth = parseFloat(document.getElementById('solar-growth').value) / 100;

        document.getElementById('carbon-price-value').textContent = `$${carbonPrice}`;
        document.getElementById('solar-alpha-value').textContent = solarAlpha.toFixed(2);
        document.getElementById('solar-growth-value').textContent = `${(solarGrowth * 100).toFixed(0)}%`;

        const { years, results, demographics: demographicsData } = runSimulation({ carbonPrice, solarAlpha, solarGrowth });
        currentDemographicsData = demographicsData;
        const crossovers = findCrossovers(years, results);

        // Update metrics
        const solarGasCross = crossovers.find(c => c.event.includes('Solar LCOE'));
        document.getElementById('solar-gas-cross').textContent = solarGasCross ? solarGasCross.year : 'Already';

        const solarBattGasCross = crossovers.find(c => c.event.includes('Solar+Battery'));
        document.getElementById('solar-battery-gas-cross').textContent = solarBattGasCross ? solarBattGasCross.year : 'Already';

        const coalUneconomic = crossovers.find(c => c.event.includes('Coal'));
        document.getElementById('coal-uneconomic').textContent = coalUneconomic ? coalUneconomic.year : 'Already';

        const battery2035Index = years.indexOf(2035);
        document.getElementById('battery-2035').textContent = `$${results.battery[battery2035Index].toFixed(0)}`;

        // Update demographic metrics
        const popPeak = findPopulationPeak(demographicsData.global.population, demographicsData.years);
        document.getElementById('pop-peak').textContent = popPeak.year;

        const dep2075Index = demographicsData.years.indexOf(2075);
        const dep2025Index = 0;
        const dep2025 = (demographicsData.global.dependency[dep2025Index] * 100).toFixed(0);
        const dep2075 = (demographicsData.global.dependency[dep2075Index] * 100).toFixed(0);
        document.getElementById('dependency-2075').textContent = `${dep2025}% → ${dep2075}%`;

        // Update crossover events
        const eventsHtml = crossovers.map(c => `
            <div class="insight-item">
                <span class="insight-year">${c.year}</span>: ${c.event}<br>
                <span style="color: #666; font-size: 13px;">${c.detail}</span>
            </div>
        `).join('');
        document.getElementById('crossover-events').innerHTML = eventsHtml || '<div class="insight-item">No crossovers detected in this scenario</div>';

        // Update era table
        const eras = ['2025-29', '2030-34', '2035-39', '2040-44', '2045-49', '2050-54', '2055-59', '2060-64', '2065-69', '2070-74', '2075-79', '2080-84', '2085-89', '2090-94', '2095-99'];
        const tbody = document.getElementById('era-tbody');
        tbody.innerHTML = '';

        for (let e = 0; e < eras.length; e++) {
            const startIdx = e * 5;
            const endIdx = Math.min(startIdx + 5, years.length);

            // Average over era
            const avg = (arr) => {
                let sum = 0;
                for (let i = startIdx; i < endIdx; i++) sum += arr[i];
                return sum / (endIdx - startIdx);
            };

            const row = document.createElement('tr');

            // Check if this era has a crossover
            const eraStart = 2025 + e * 5;
            const eraEnd = eraStart + 4;
            const hasCrossover = crossovers.some(c => c.year >= eraStart && c.year <= eraEnd);
            if (hasCrossover) row.classList.add('crossover-highlight');

            // Average dependency for era
            const avgDep = (arr) => {
                let sum = 0;
                for (let i = startIdx; i < endIdx; i++) sum += arr[i];
                return sum / (endIdx - startIdx);
            };

            row.innerHTML = `
                <td>${eras[e]}</td>
                <td>$${avg(results.solar).toFixed(0)}</td>
                <td>$${avg(results.wind).toFixed(0)}</td>
                <td>$${avg(results.gas).toFixed(0)}</td>
                <td>$${avg(results.coal).toFixed(0)}</td>
                <td>$${avg(results.nuclear).toFixed(0)}</td>
                <td>$${avg(results.battery).toFixed(0)}/kWh</td>
                <td>$${avg(results.solarPlusBattery).toFixed(0)}</td>
                <td>${(avgDep(demographicsData.global.dependency) * 100).toFixed(0)}%</td>
            `;
            tbody.appendChild(row);
        }

        // LCOE Chart
        const lcoeCtx = document.getElementById('lcoe-chart').getContext('2d');

        if (lcoeChart) lcoeChart.destroy();

        lcoeChart = new Chart(lcoeCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Solar',
                        data: results.solar,
                        borderColor: energySources.solar.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Wind',
                        data: results.wind,
                        borderColor: energySources.wind.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Gas',
                        data: results.gas,
                        borderColor: energySources.gas.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Coal',
                        data: results.coal,
                        borderColor: energySources.coal.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Nuclear',
                        data: results.nuclear,
                        borderColor: energySources.nuclear.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Solar+Battery',
                        data: results.solarPlusBattery,
                        borderColor: '#ff006e',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: $${context.parsed.y.toFixed(0)}/MWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return '$' + value;
                            }
                        },
                        title: {
                            display: true,
                            text: '$/MWh',
                            color: '#888'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });

        // Custom legend
        const legendHtml = [
            { label: 'Solar', color: energySources.solar.color },
            { label: 'Wind', color: energySources.wind.color },
            { label: 'Gas', color: energySources.gas.color },
            { label: 'Coal', color: energySources.coal.color },
            { label: 'Nuclear', color: energySources.nuclear.color },
            { label: 'Solar+Battery', color: '#ff006e' }
        ].map(item => `
            <div class="legend-item">
                <div class="legend-color" style="background: ${item.color}"></div>
                ${item.label}
            </div>
        `).join('');
        document.getElementById('chart-legend').innerHTML = legendHtml;

        // Battery Chart
        const batteryCtx = document.getElementById('battery-chart').getContext('2d');

        if (batteryChart) batteryChart.destroy();

        batteryChart = new Chart(batteryCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [{
                    label: 'Battery $/kWh',
                    data: results.battery,
                    borderColor: energySources.battery.color,
                    backgroundColor: 'rgba(6, 214, 160, 0.1)',
                    fill: true,
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `$${context.parsed.y.toFixed(0)}/kWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return '$' + value;
                            }
                        },
                        title: {
                            display: true,
                            text: '$/kWh',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Population Chart (stacked area)
        const popCtx = document.getElementById('population-chart').getContext('2d');
        if (populationChart) populationChart.destroy();

        populationChart = new Chart(popCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'OECD',
                        data: demographicsData.regions.oecd.population.map(p => p / 1e9),
                        borderColor: demographics.oecd.color,
                        backgroundColor: demographics.oecd.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demographicsData.regions.china.population.map(p => p / 1e9),
                        borderColor: demographics.china.color,
                        backgroundColor: demographics.china.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demographicsData.regions.em.population.map(p => p / 1e9),
                        borderColor: demographics.em.color,
                        backgroundColor: demographics.em.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demographicsData.regions.row.population.map(p => p / 1e9),
                        borderColor: demographics.row.color,
                        backgroundColor: demographics.row.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}B`;
                            },
                            footer: function(items) {
                                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${total.toFixed(2)}B`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        stacked: true,
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + 'B';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Population (Billions)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Dependency Ratio Chart
        const depCtx = document.getElementById('dependency-chart').getContext('2d');
        if (dependencyChart) dependencyChart.destroy();

        dependencyChart = new Chart(depCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'Global',
                        data: demographicsData.global.dependency.map(d => d * 100),
                        borderColor: '#fff',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'OECD',
                        data: demographicsData.regions.oecd.dependency.map(d => d * 100),
                        borderColor: demographics.oecd.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demographicsData.regions.china.dependency.map(d => d * 100),
                        borderColor: demographics.china.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demographicsData.regions.em.dependency.map(d => d * 100),
                        borderColor: demographics.em.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demographicsData.regions.row.dependency.map(d => d * 100),
                        borderColor: demographics.row.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Old-Age Dependency Ratio (65+ / 20-64)',
                            color: '#888'
                        }
                    }
                }
            }
        });
    }

    // Event listeners
    document.getElementById('carbon-price').addEventListener('input', updateCharts);
    document.getElementById('solar-alpha').addEventListener('input', updateCharts);
    document.getElementById('solar-growth').addEventListener('input', updateCharts);

    // CSV Export
    document.getElementById('export-csv').addEventListener('click', function() {
        if (!currentDemographicsData) return;
        const csv = exportDemographicsCSV(currentDemographicsData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'demographics_2025_2100.csv';
        a.click();
        URL.revokeObjectURL(url);
    });

    // Initial render
    updateCharts();

    // Console API for testing
    window.energySim = {
        compound,
        learningCurve,
        depletion,
        logistic,
        poissonShock,
        runSimulation,
        runDemographics,
        findCrossovers,
        findPopulationPeak,
        exportDemographicsCSV,
        projectFertility,
        energySources,
        demographics,
        get demographicsData() { return currentDemographicsData; }
    };

    console.log('Energy Simulation loaded. Access primitives via window.energySim');
    console.log('Test: energySim.learningCurve(100, 2, 0.2) =', learningCurve(100, 2, 0.2).toFixed(2), '(should be ~87 - 13% reduction per doubling)');
    console.log('Demographics loaded. Access via window.energySim.demographicsData');
    console.log('Try: energySim.demographicsData.regions.china.working[50] for China working-age pop in 2075');
    </script>
</body>
</html>
