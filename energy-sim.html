<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Futures: 2025-2100</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .chart-container {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
        }
        .metric-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #4cc9f0;
        }
        .metric-detail {
            font-size: 12px;
            color: #666;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: right;
        }
        th {
            background: #0f3460;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        tr:nth-child(even) {
            background: #1a1a3e;
        }
        tr:hover {
            background: #1f4068;
        }
        .crossover-highlight {
            background: #2d6a4f !important;
        }
        .controls {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-label {
            font-size: 13px;
            color: #888;
            margin-bottom: 8px;
            display: block;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
        }
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            color: #4cc9f0;
        }
        .insights {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .insight-item {
            padding: 10px 0;
            border-bottom: 1px solid #0f3460;
        }
        .insight-item:last-child {
            border-bottom: none;
        }
        .insight-year {
            color: #4cc9f0;
            font-weight: 600;
        }
        .legend-custom {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>Energy Futures: 2025-2100</h1>
    <p class="subtitle">Phase 4: Climate module with emissions, warming, and economic damages (DICE-2023)</p>

    <div class="metrics-grid">
        <div class="metric-card">
            <div class="metric-label">Solar Crosses Gas</div>
            <div class="metric-value" id="solar-gas-cross">--</div>
            <div class="metric-detail">Year when solar LCOE &lt; gas LCOE</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Solar+Battery Crosses Gas</div>
            <div class="metric-value" id="solar-battery-gas-cross">--</div>
            <div class="metric-detail">Dispatchable clean energy milestone</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Coal Uneconomic</div>
            <div class="metric-value" id="coal-uneconomic">--</div>
            <div class="metric-detail">Year coal LCOE &gt; cheapest clean</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Battery Cost 2035</div>
            <div class="metric-value" id="battery-2035">--</div>
            <div class="metric-detail">$/kWh storage cost</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Global Pop Peak</div>
            <div class="metric-value" id="pop-peak">--</div>
            <div class="metric-detail">Year population peaks</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Global Dependency 2075</div>
            <div class="metric-value" id="dependency-2075">--</div>
            <div class="metric-detail">Old-age dependency ratio</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Global Electricity 2050</div>
            <div class="metric-value" id="elec-2050">--</div>
            <div class="metric-detail">TWh projected demand</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Electrification 2050</div>
            <div class="metric-value" id="electrification-2050">--</div>
            <div class="metric-detail">Share of useful energy</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">kWh/Worker 2050</div>
            <div class="metric-value" id="kwh-worker-2050">--</div>
            <div class="metric-detail">Per working-age adult</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Grid Intensity 2025</div>
            <div class="metric-value" id="grid-intensity-2025">--</div>
            <div class="metric-detail">kg CO2/MWh</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Peak Emissions Year</div>
            <div class="metric-value" id="peak-emissions">--</div>
            <div class="metric-detail">When global CO2 peaks</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Warming 2100</div>
            <div class="metric-value" id="warming-2100">--</div>
            <div class="metric-detail">Degrees C above preindustrial</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Climate Damages 2075</div>
            <div class="metric-value" id="damages-2075">--</div>
            <div class="metric-detail">% GDP lost to warming</div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label class="control-label">Carbon Price ($/ton CO₂)</label>
            <div class="slider-container">
                <input type="range" id="carbon-price" min="0" max="200" value="50" step="10">
                <span class="slider-value" id="carbon-price-value">$50</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Solar Learning Rate (α) — Farmer/Naam: 0.36-0.51</label>
            <div class="slider-container">
                <input type="range" id="solar-alpha" min="0.15" max="0.55" value="0.36" step="0.01">
                <span class="slider-value" id="solar-alpha-value">0.36</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Solar Capacity Growth Rate (%/year)</label>
            <div class="slider-container">
                <input type="range" id="solar-growth" min="10" max="40" value="25" step="1">
                <span class="slider-value" id="solar-growth-value">25%</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Electrification Target (2050+)</label>
            <div class="slider-container">
                <input type="range" id="electrification-target" min="50" max="85" value="65" step="1">
                <span class="slider-value" id="electrification-target-value">65%</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Energy Efficiency Improvement Multiplier</label>
            <div class="slider-container">
                <input type="range" id="efficiency-mult" min="0.5" max="1.5" value="1.0" step="0.05">
                <span class="slider-value" id="efficiency-mult-value">1.0×</span>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Climate Sensitivity (°C per CO2 doubling) — IPCC range: 2.0-4.5</label>
            <div class="slider-container">
                <input type="range" id="clim-sensitivity" min="2.0" max="4.5" value="3.0" step="0.1">
                <span class="slider-value" id="clim-sensitivity-value">3.0°C</span>
            </div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Levelized Cost of Energy (LCOE) Trajectories</div>
        <canvas id="lcoe-chart"></canvas>
        <div class="legend-custom" id="chart-legend"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Battery Storage Cost Trajectory</div>
        <canvas id="battery-chart"></canvas>
    </div>

    <div class="insights">
        <div class="chart-title">Key Crossover Events</div>
        <div id="crossover-events"></div>
    </div>

    <div class="chart-container">
        <div class="chart-title">Global Population by Region (Billions)</div>
        <canvas id="population-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Old-Age Dependency Ratio by Region</div>
        <canvas id="dependency-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Regional Electricity Demand (TWh)</div>
        <canvas id="demand-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">GDP per Working-Age Adult ($ thousands)</div>
        <canvas id="gdp-per-worker-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Energy Intensity Decline (MWh per $1000 GDP)</div>
        <canvas id="intensity-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Generation Mix by Source (TWh)</div>
        <canvas id="generation-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">CO2 Emissions (Gt/year)</div>
        <canvas id="emissions-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Temperature Trajectory (°C above preindustrial)</div>
        <canvas id="temperature-chart"></canvas>
    </div>

    <div class="chart-container">
        <div class="chart-title">Climate Damages by Region (% GDP)</div>
        <canvas id="damages-chart"></canvas>
    </div>

    <table id="era-table">
        <thead>
            <tr>
                <th>Era</th>
                <th>Solar</th>
                <th>Wind</th>
                <th>Gas</th>
                <th>Coal</th>
                <th>Nuclear</th>
                <th>Battery</th>
                <th>Solar+Batt</th>
                <th>Emissions</th>
                <th>Temp</th>
                <th>Damages</th>
            </tr>
        </thead>
        <tbody id="era-tbody"></tbody>
    </table>

    <div class="controls" style="text-align: center; display: flex; gap: 15px; justify-content: center;">
        <button id="export-csv" style="background: #4cc9f0; color: #000; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 600;">Export Demographics CSV</button>
        <button id="export-json" style="background: #90be6d; color: #000; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: 600;">Export Full JSON</button>
    </div>

    <script>
    // =============================================================================
    // PRIMITIVES - Core mathematical functions
    // =============================================================================

    /**
     * Compound growth: start × (1 + rate)^years
     */
    function compound(start, rate, years) {
        return start * Math.pow(1 + rate, years);
    }

    /**
     * Wright's Law learning curve: cost = cost₀ × cumulative^(-α)
     * As cumulative production doubles, cost falls by 2^(-α)
     * α=0.20 means 13% cost reduction per doubling (1 - 2^-0.2 ≈ 0.13)
     */
    function learningCurve(cost0, cumulative, alpha) {
        if (cumulative <= 0) return cost0;
        return cost0 * Math.pow(cumulative, -alpha);
    }

    /**
     * EROEI depletion: EROEI declines as resources are extracted
     * EROEI(t) = EROEI₀ × (remaining/initial)^β
     * Net energy = gross × (1 - 1/EROEI)
     */
    function depletion(reserves, extracted, eroei0, beta = 0.5) {
        const remaining = Math.max(reserves - extracted, 0.01);
        const fractionRemaining = remaining / reserves;
        const eroei = eroei0 * Math.pow(fractionRemaining, beta);
        return {
            eroei: Math.max(eroei, 1.1), // EROEI can't go below ~1
            netEnergyFraction: 1 - 1 / Math.max(eroei, 1.1),
            remaining
        };
    }

    /**
     * Logistic S-curve: models adoption/deployment
     * Returns value between 0 and ceiling
     */
    function logistic(start, ceiling, rate, years) {
        const k = rate;
        const midpoint = Math.log((ceiling - start) / start) / k;
        return ceiling / (1 + Math.exp(-k * (years - midpoint)));
    }

    /**
     * Poisson shock probability: P(at least one event) = 1 - e^(-λ)
     */
    function poissonShock(lambda, magnitude) {
        const prob = 1 - Math.exp(-lambda);
        return { probability: prob, magnitude };
    }

    // =============================================================================
    // ENERGY SOURCES - Parameters and cost models
    // =============================================================================

    /**
     * Energy source parameters (calibration constants)
     *
     * INPUTS (user-tuneable via sliders):
     * - solar.alpha: Learning rate (slider)
     * - solar.growthRate: Capacity growth (slider, passed to runSimulation)
     * - carbonPrice: Applied to gas/coal (slider, passed to runSimulation)
     *
     * INPUTS (calibration constants, not user-tuneable):
     * - cost0: 2025 baseline LCOE in $/MWh
     * - alpha: Wright's Law exponent (except solar, which is tuneable)
     * - capacity2025: Installed capacity in 2025
     * - growthRate: Annual capacity growth rate
     * - carbonIntensity: kg CO₂/MWh
     * - reserves, extractionRate, eroei0: Fossil fuel depletion
     *
     * OUTPUTS (computed by runSimulation):
     * - LCOE trajectories over time
     * - Crossover years between sources
     *
     * Learning rates calibrated to Farmer/Way (2022) and Naam (2020)
     * α: Wright's Law exponent. Learning rate = 1 - 2^(-α)
     * α=0.36 → 25% cost reduction per doubling
     * α=0.23 → 15% cost reduction per doubling
     */
    const energySources = {
        solar: {
            name: 'Solar PV',
            cost0: 35,           // $/MWh in 2025 (Naam: $30-40)
            alpha: 0.36,         // 25% learning rate (Naam: 30-40%, DOE: 24%)
            capacity2025: 1500,  // GW installed globally
            growthRate: 0.25,    // 25% annual growth (historical: 40%)
            carbonIntensity: 0,  // kg CO₂/MWh
            color: '#ffd60a'
        },
        wind: {
            name: 'Wind',
            cost0: 35,           // $/MWh in 2025
            alpha: 0.23,         // 15% learning rate (DOE/LBNL full-period)
            capacity2025: 1000,
            growthRate: 0.18,    // 18% annual growth (Farmer: 20-25%)
            carbonIntensity: 0,
            color: '#4cc9f0'
        },
        gas: {
            name: 'Natural Gas',
            cost0: 45,           // $/MWh in 2025 (slightly higher base)
            eroei0: 30,          // Starting EROEI
            reserves: 200,       // Arbitrary units
            extractionRate: 2,   // Units per year
            carbonIntensity: 400,// kg CO₂/MWh
            color: '#f77f00'
        },
        coal: {
            name: 'Coal',
            cost0: 40,           // $/MWh in 2025
            eroei0: 25,
            reserves: 500,
            extractionRate: 3,
            carbonIntensity: 900,
            color: '#6c757d'
        },
        nuclear: {
            name: 'Nuclear',
            cost0: 90,
            alpha: 0.0,          // No learning (regulatory/political stagnation)
            capacity2025: 400,
            growthRate: 0.02,
            carbonIntensity: 0,
            color: '#9d4edd'
        },
        battery: {
            name: 'Battery Storage',
            cost0: 140,          // $/kWh in 2025 (BloombergNEF: ~$130-150)
            alpha: 0.26,         // 18% learning rate (Naam: 20%, BNEF: 18%)
            capacity2025: 100,   // GWh
            growthRate: 0.35,    // Rapid growth
            color: '#06d6a0'
        }
    };

    // =============================================================================
    // DISPATCH - Merit order dispatch parameters
    // =============================================================================

    /**
     * Dispatch parameters for source allocation
     *
     * INPUTS (calibration constants, not user-tuneable):
     * - capacityFactor: Fraction of nameplate capacity available (solar ~20%, nuclear ~90%)
     * - maxPenetration: Maximum share of generation (VRE limited without storage)
     *
     * Theoretical basis: Merit order dispatch - cheapest sources used first,
     * subject to capacity and penetration constraints.
     */
    const dispatchParams = {
        solar: { capacityFactor: 0.20, maxPenetration: 0.40 },
        wind: { capacityFactor: 0.30, maxPenetration: 0.35 },
        solarPlusBattery: { capacityFactor: 0.20, maxPenetration: 0.80 },
        gas: { capacityFactor: 0.50, maxPenetration: 1.0 },
        coal: { capacityFactor: 0.60, maxPenetration: 1.0 },
        nuclear: { capacityFactor: 0.90, maxPenetration: 0.30 }
    };

    // =============================================================================
    // CLIMATE - Emissions and damage parameters
    // =============================================================================

    /**
     * Climate model parameters
     *
     * INPUTS (user-tuneable via slider):
     * - climSensitivity: Equilibrium climate sensitivity (2.0-4.5°C per CO₂ doubling)
     *
     * INPUTS (calibration constants):
     * - preindustrialCO2: 280 ppm baseline
     * - currentCO2: 420 ppm in 2025
     * - cumulativeCO2_2025: ~2400 Gt cumulative emissions since preindustrial
     * - airborneraction: 45% of emissions remain in atmosphere
     * - ppmPerGt: CO₂ ppm increase per Gt of emissions in atmosphere
     * - temperatureLag: Years for temperature to catch up to forcing
     * - damageCoeff: DICE-2023 quadratic damage coefficient
     * - regionalDamage: Multipliers by region (OECD lower, ROW higher)
     * - tippingThreshold: Temperature threshold for accelerated damages
     * - maxDamage: Cap on damage fraction (Weitzman bounded utility)
     *
     * Sources:
     * - DICE-2023 (Nordhaus/Barrage): damageCoeff, updated damage estimates
     * - Weitzman: Fat-tailed uncertainty, bounded damages
     * - IPCC AR6: Climate sensitivity range
     * - IEA: 2025 emissions calibration (~35 Gt total)
     */
    const climateParams = {
        preindustrialCO2: 280,          // ppm
        currentCO2: 420,                 // ppm in 2025
        cumulativeCO2_2025: 2400,       // Gt cumulative since preindustrial
        airborneraction: 0.45,          // Fraction staying in atmosphere
        ppmPerGt: 0.128,                // ppm per Gt in atmosphere
        temperatureLag: 10,             // Years for temp to equilibrate
        climSensitivity: 3.0,           // °C per CO₂ doubling (slider: 2.0-4.5)
        currentTemp: 1.2,               // °C above preindustrial in 2025
        damageCoeff: 0.00236,           // DICE-2023 coefficient
        regionalDamage: {
            oecd: 0.8,                  // Richer countries more resilient
            china: 1.0,                 // Middle
            em: 1.3,                    // More vulnerable
            row: 1.8                    // Most vulnerable (Africa, etc.)
        },
        tippingThreshold: 2.5,          // °C threshold for tipping points
        tippingMultiplier: 1.25,        // Damage multiplier above threshold
        maxDamage: 0.30,                // Cap damages at 30% GDP
        nonElecEmissions2025: 25        // Gt CO₂ from non-electricity (transport, industry, etc.)
    };

    // =============================================================================
    // SIMULATION DEFAULTS AND CONFIG
    // =============================================================================

    /**
     * Default simulation parameters (matches slider defaults)
     * Use energySim.defaults to see these without scanning the DOM
     */
    const defaults = {
        carbonPrice: 50,              // $/ton CO₂
        solarAlpha: 0.36,             // Wright's Law exponent (learning rate)
        solarGrowth: 0.25,            // 25% annual capacity growth
        electrificationTarget: 0.65,  // 65% of useful energy from electricity
        efficiencyMultiplier: 1.0,    // Multiplier on intensity decline rates
        climSensitivity: 3.0          // °C per CO₂ doubling
    };

    /**
     * Runtime configuration
     */
    const config = {
        quiet: false  // Set to true to suppress console warnings (e.g., dispatch shortfall)
    };

    // =============================================================================
    // DEMOGRAPHICS - Fernández-Villaverde-informed population model
    // =============================================================================

    /**
     * Regional demographic parameters (2025 baseline)
     *
     * INPUTS (calibration constants, not user-tuneable):
     * - pop2025: Starting population (UN data)
     * - fertility: 2025 TFR (total fertility rate)
     * - fertilityFloor: Long-term TFR convergence target
     * - fertilityDecay: Annual convergence rate toward floor
     * - lifeExpectancy: 2025 life expectancy at birth
     * - young/working/old: 2025 age cohort shares (must sum to 1)
     * - migrationRate: Net migration as fraction of population
     *
     * OUTPUTS (computed by runDemographics):
     * - Population trajectories per region
     * - Working-age population (used by demand model)
     * - Old-age dependency ratio (used by demand model)
     * - Fertility trajectories
     *
     * Theoretical basis: Fernández-Villaverde's thesis that global fertility
     * is converging faster than expected, with all regions trending toward
     * below-replacement rates.
     */
    const demographics = {
        oecd: {
            name: 'OECD',
            pop2025: 1.4e9,           // 1.4 billion
            fertility: 1.6,           // TFR (below replacement)
            fertilityFloor: 1.4,      // Long-term convergence target
            fertilityDecay: 0.005,    // Annual convergence rate
            lifeExpectancy: 82,
            young: 0.18,              // 0-19 share
            working: 0.59,            // 20-64 share
            old: 0.23,                // 65+ share (high, aging societies)
            migrationRate: 0.003,     // net immigration (helps offset aging)
            color: '#4cc9f0'
        },
        china: {
            name: 'China',
            pop2025: 1.4e9,
            fertility: 1.05,          // Very low TFR (lower than reported due to measurement issues)
            fertilityFloor: 0.85,     // Could go very low (South Korea at 0.7)
            fertilityDecay: 0.012,    // Faster decline
            lifeExpectancy: 78,
            young: 0.16,              // Already shrinking
            working: 0.68,            // Still large working-age cohort
            old: 0.16,                // Rising fast
            migrationRate: 0.0,
            color: '#f94144'
        },
        em: {  // Emerging Markets (India, Brazil, Indonesia, etc.)
            name: 'Emerging Markets',
            pop2025: 3.5e9,
            fertility: 2.1,           // Near replacement
            fertilityFloor: 1.4,      // Converging faster than expected
            fertilityDecay: 0.02,     // Faster convergence (Colombia at 1.06!)
            lifeExpectancy: 72,
            young: 0.27,
            working: 0.63,
            old: 0.10,                // Still relatively young
            migrationRate: -0.001,
            color: '#90be6d'
        },
        row: {  // Rest of World (Africa, etc.)
            name: 'Rest of World',
            pop2025: 2.0e9,
            fertility: 3.5,           // Still high but falling fast
            fertilityFloor: 1.6,      // Even Africa converging
            fertilityDecay: 0.03,     // Fast decline (Fernández-Villaverde: converging faster than expected)
            lifeExpectancy: 65,
            young: 0.40,              // Very young population
            working: 0.54,
            old: 0.06,
            migrationRate: -0.001,
            color: '#f9c74f'
        }
    };

    /**
     * Project fertility rate with convergence to floor
     * TFR(t) = TFR_floor + (TFR_0 - TFR_floor) × e^(-decay × t)
     */
    function projectFertility(tfr0, floor, decay, years) {
        return floor + (tfr0 - floor) * Math.exp(-decay * years);
    }

    /**
     * Calculate crude birth rate from TFR
     * CBR ≈ TFR × (women of childbearing age 15-49 as fraction of pop) / average age span
     * Calibrated to produce ~18 births per 1000 globally in 2025
     */
    function birthRateFromTFR(tfr, workingShare, youngShare) {
        // Women 15-49 are roughly split between young (15-19) and working (20-49) cohorts
        // Approximate: 0.25 of young + 0.65 of working are women 15-49
        const womenOfChildbearingAge = youngShare * 0.25 + workingShare * 0.65;
        // Divide by 2 (only women) and by 32 (average childbearing span)
        return (tfr * womenOfChildbearingAge * 0.5) / 32;
    }

    /**
     * Calculate crude death rate based on age structure and life expectancy
     * CDR ≈ 1/LE adjusted for age structure
     * Calibrated to produce ~8 deaths per 1000 globally in 2025
     */
    function deathRate(youngShare, workingShare, oldShare, lifeExpectancy) {
        // Age-specific mortality rates (approximate)
        // Young: very low mortality, Working: low mortality, Old: moderate (people live long in old cohort)
        const youngMortality = 0.001;  // 0.1% per year
        const workingMortality = 0.003; // 0.3% per year
        // Remaining life expectancy at 65 is about LE - 65 + 10 (selection effects)
        const remainingLEat65 = Math.max(15, lifeExpectancy - 55);
        const oldMortality = 1 / remainingLEat65;

        return youngShare * youngMortality +
               workingShare * workingMortality +
               oldShare * oldMortality;
    }

    /**
     * Age cohorts forward by one year
     * 3-cohort model: Young (0-19), Working (20-64), Old (65+)
     * Calibrated for realistic population dynamics
     */
    function ageCohorts(region, tfr, year) {
        const { young, working, old, migrationRate, lifeExpectancy } = region;
        const pop = region.population;

        // Calculate births and deaths using improved formulas
        const births = birthRateFromTFR(tfr, working, young) * pop;
        const deaths = deathRate(young, working, old, lifeExpectancy) * pop;

        // Aging transitions
        // Young cohort: 20 years, so 1/20 age out per year
        // Working cohort: 45 years (20-64), so 1/45 age out per year
        const agingOutOfYoung = (young * pop) / 20;
        const agingOutOfWorking = (working * pop) / 45;

        // Deaths by cohort (proportional to mortality rates)
        const youngDeaths = young * pop * 0.001;
        const workingDeaths = working * pop * 0.002;
        const oldDeaths = deaths - youngDeaths - workingDeaths;

        // New cohort sizes
        const newYoung = Math.max(0, young * pop + births - agingOutOfYoung - youngDeaths);
        const newWorking = Math.max(0, working * pop + agingOutOfYoung - agingOutOfWorking - workingDeaths);
        const newOld = Math.max(0, old * pop + agingOutOfWorking - Math.max(0, oldDeaths));

        // Apply migration (to working-age primarily)
        const migration = pop * migrationRate;
        const adjustedWorking = newWorking + migration * 0.8;
        const adjustedYoung = newYoung + migration * 0.15;
        const adjustedOld = newOld + migration * 0.05;

        const newPop = adjustedYoung + adjustedWorking + adjustedOld;

        return {
            population: newPop,
            young: adjustedYoung / newPop,
            working: adjustedWorking / newPop,
            old: adjustedOld / newPop,
            youngAbs: adjustedYoung,
            workingAbs: adjustedWorking,
            oldAbs: adjustedOld
        };
    }

    /**
     * Run full demographics simulation for 2025-2100
     * Returns yearly data by region and global aggregates
     */
    function runDemographics() {
        const years = [];
        const regions = {
            oecd: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            china: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            em: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] },
            row: { population: [], young: [], working: [], old: [], fertility: [], dependency: [] }
        };
        const global = { population: [], young: [], working: [], old: [], dependency: [] };

        // Initialize current state for each region
        const currentState = {};
        for (const [key, params] of Object.entries(demographics)) {
            currentState[key] = {
                population: params.pop2025,
                young: params.young,
                working: params.working,
                old: params.old,
                lifeExpectancy: params.lifeExpectancy,
                migrationRate: params.migrationRate
            };
        }

        for (let year = 2025; year <= 2100; year++) {
            const t = year - 2025;
            years.push(year);

            let globalPop = 0, globalYoung = 0, globalWorking = 0, globalOld = 0;

            for (const [key, params] of Object.entries(demographics)) {
                // Project fertility for this year
                const tfr = projectFertility(params.fertility, params.fertilityFloor, params.fertilityDecay, t);
                regions[key].fertility.push(tfr);

                // Store current values
                const state = currentState[key];
                regions[key].population.push(state.population);
                regions[key].young.push(state.young * state.population);
                regions[key].working.push(state.working * state.population);
                regions[key].old.push(state.old * state.population);
                regions[key].dependency.push(state.old / state.working);

                // Accumulate global totals
                globalPop += state.population;
                globalYoung += state.young * state.population;
                globalWorking += state.working * state.population;
                globalOld += state.old * state.population;

                // Age forward for next year (except last year)
                if (year < 2100) {
                    const nextState = ageCohorts(state, tfr, year);
                    currentState[key] = {
                        ...nextState,
                        lifeExpectancy: params.lifeExpectancy + t * 0.1, // Slow improvement
                        migrationRate: params.migrationRate
                    };
                }
            }

            // Store global aggregates
            global.population.push(globalPop);
            global.young.push(globalYoung);
            global.working.push(globalWorking);
            global.old.push(globalOld);
            global.dependency.push(globalOld / globalWorking);
        }

        return { years, regions, global };
    }

    /**
     * Find year of peak population
     */
    function findPopulationPeak(populationArray, years) {
        let maxPop = 0;
        let peakYear = years[0];
        for (let i = 0; i < populationArray.length; i++) {
            if (populationArray[i] > maxPop) {
                maxPop = populationArray[i];
                peakYear = years[i];
            }
        }
        return { year: peakYear, population: maxPop };
    }

    // =============================================================================
    // DEMAND MODEL - GDP, energy intensity, and electricity demand
    // =============================================================================

    /**
     * Regional economic parameters (2025 baseline)
     *
     * INPUTS (calibration constants, not user-tuneable):
     * - gdp2025: Regional GDP in trillions USD (World Bank data)
     * - tfpGrowth: Total factor productivity growth rate
     * - tfpDecay: Rate at which catch-up growth fades (convergence)
     * - energyIntensity: MWh per $1000 GDP (calibrated to 2025 electricity data)
     * - intensityDecline: Annual efficiency improvement rate
     *
     * Theoretical basis:
     * - Fernández-Villaverde: GDP per working-age adult as key metric
     * - Ole Peters: Ergodicity economics (time-average vs ensemble-average)
     * - Odum: Energy as basis of real wealth
     *
     * Energy intensity calibrated to match ~30,000 TWh global electricity in 2025:
     * - OECD: ~10,000 TWh, $58T GDP → 0.43 MWh/$1000 total energy, 40% electric
     * - China: ~9,000 TWh, $18T GDP → 1.25 MWh/$1000 total energy
     * - EM: ~8,000 TWh, $35T GDP → 0.57 MWh/$1000 total energy
     * - ROW: ~3,000 TWh, $8T GDP → 0.94 MWh/$1000 total energy
     */
    const economicParams = {
        oecd: {
            gdp2025: 58,              // $58T (World Bank)
            tfpGrowth: 0.015,         // 1.5% baseline TFP
            tfpDecay: 0.0,            // Mature economy - no convergence
            energyIntensity: 0.43,    // MWh per $1000 GDP (total energy)
            intensityDecline: 0.010   // 1.0%/year efficiency gains
        },
        china: {
            gdp2025: 18,              // $18T (World Bank)
            tfpGrowth: 0.035,         // 3.5% catch-up growth
            tfpDecay: 0.015,          // Converging toward OECD
            energyIntensity: 1.25,    // High - industrial economy
            intensityDecline: 0.020   // 2.0%/year (rapid improvement)
        },
        em: {
            gdp2025: 35,              // $35T (India, Brazil, Indonesia, etc.)
            tfpGrowth: 0.025,         // 2.5% baseline
            tfpDecay: 0.008,          // Slow convergence
            energyIntensity: 0.57,    // Mixed economies
            intensityDecline: 0.015   // 1.5%/year
        },
        row: {
            gdp2025: 8,               // $8T (Africa, etc.)
            tfpGrowth: 0.030,         // 3.0% demographic dividend
            tfpDecay: 0.010,          // Gradual convergence
            energyIntensity: 0.94,    // Lower efficiency
            intensityDecline: 0.012   // 1.2%/year
        }
    };

    /**
     * Global demand model parameters
     *
     * INPUTS (user-tuneable via sliders):
     * - electrificationTarget: Target electricity share (slider)
     * - efficiencyMultiplier: Scales intensity decline (slider, passed to runDemandModel)
     *
     * INPUTS (calibration constants):
     * - electrification2025: Current electricity share of useful energy (IEA)
     * - electrificationSpeed: Logistic convergence rate
     * - demographicFactor: How much dependency ratio affects GDP growth
     *
     * Note: baselineDependency is computed from demographics model output,
     * not hardcoded, ensuring consistency between models.
     */
    const demandParams = {
        electrification2025: 0.40,    // Current electricity share (IEA data)
        electrificationTarget: 0.65,  // 2050+ target (IEA Net Zero)
        electrificationSpeed: 0.08,   // Convergence rate
        demographicFactor: 0.015      // Dependency ratio impact on growth
    };

    /**
     * Run demand model simulation
     * Calculates GDP growth, energy intensity, and electricity demand by region
     *
     * INPUTS (from parameters):
     * - electrificationTarget: Target electricity share of useful energy (slider)
     * - efficiencyMultiplier: Scales intensity decline rates (slider)
     *
     * INPUTS (from demographicsData - computed by Phase 2):
     * - working-age population per region
     * - dependency ratios per region
     *
     * OUTPUTS:
     * - GDP trajectories per region
     * - Electricity demand per region (TWh)
     * - GDP per working-age adult
     * - kWh per working-age adult
     *
     * @param {Object} demographicsData - Output from runDemographics()
     * @param {Object} params - Optional overrides for electrification target, efficiency
     * @returns {Object} Demand data structure with regional and global projections
     */
    function runDemandModel(demographicsData, params = {}) {
        const { years, regions: demoRegions, global: demoGlobal } = demographicsData;
        const electTarget = params.electrificationTarget ?? demandParams.electrificationTarget;
        const efficiencyMult = params.efficiencyMultiplier ?? 1.0;

        // Compute baseline dependency from demographics model (not hardcoded)
        const baselineDependency = demoGlobal.dependency[0];

        const demand = {
            regions: {
                oecd: { gdp: [], growthRate: [], energyIntensity: [], electricityDemand: [], gdpPerWorking: [], electricityPerWorking: [] },
                china: { gdp: [], growthRate: [], energyIntensity: [], electricityDemand: [], gdpPerWorking: [], electricityPerWorking: [] },
                em: { gdp: [], growthRate: [], energyIntensity: [], electricityDemand: [], gdpPerWorking: [], electricityPerWorking: [] },
                row: { gdp: [], growthRate: [], energyIntensity: [], electricityDemand: [], gdpPerWorking: [], electricityPerWorking: [] }
            },
            global: {
                gdp: [],
                electricityDemand: [],
                electrificationRate: [],
                gdpPerWorking: [],
                electricityPerWorking: []
            },
            metrics: {
                elec2050: null,
                demandDoubling: null,
                asiaShare2050: null
            }
        };

        // Initialize state per region
        const state = {};
        for (const [key, econ] of Object.entries(economicParams)) {
            state[key] = {
                gdp: econ.gdp2025,
                intensity: econ.energyIntensity
            };
        }

        // Initial 2025 electricity demand (for doubling calculation)
        let initialGlobalElec = null;

        for (let i = 0; i < years.length; i++) {
            const t = i; // Years since 2025
            const year = years[i];

            // Calculate global electrification rate (logistic convergence)
            const electRate = electTarget - (electTarget - demandParams.electrification2025) *
                Math.exp(-demandParams.electrificationSpeed * t);
            demand.global.electrificationRate.push(electRate);

            let globalGdp = 0;
            let globalElec = 0;
            let globalWorking = 0;

            for (const [key, econ] of Object.entries(economicParams)) {
                const regionDemo = demoRegions[key];
                const currentState = state[key];

                // Get working-age population for this year
                const working = regionDemo.working[i];
                const workingPrev = i > 0 ? regionDemo.working[i - 1] : working;

                // Get dependency ratio
                const dependency = regionDemo.dependency[i];

                // Calculate labor growth
                const laborGrowth = i > 0 ? (working - workingPrev) / workingPrev : 0;

                // Demographic adjustment (Fernández-Villaverde)
                // Higher dependency = lower growth
                const demographicAdj = demandParams.demographicFactor *
                    (baselineDependency - dependency);

                // TFP with decay (catch-up growth fades)
                const tfp = econ.tfpGrowth * Math.pow(1 - econ.tfpDecay, t);

                // Total growth rate: TFP + labor contribution + demographic adjustment
                // Labor share (1 - α) ≈ 0.65
                const growthRate = tfp + 0.65 * laborGrowth + demographicAdj;

                // Update GDP (first year is baseline)
                if (i > 0) {
                    currentState.gdp = currentState.gdp * (1 + growthRate);
                }
                demand.regions[key].gdp.push(currentState.gdp);
                demand.regions[key].growthRate.push(growthRate);

                // Energy intensity decline (efficiency improvements)
                if (i > 0) {
                    currentState.intensity = currentState.intensity *
                        (1 - econ.intensityDecline * efficiencyMult);
                }
                demand.regions[key].energyIntensity.push(currentState.intensity);

                // Calculate electricity demand
                // Total energy = GDP × intensity × 1000 (TWh)
                const totalEnergy = currentState.gdp * currentState.intensity * 1000;
                // Electricity = total energy × electrification rate
                const elecDemand = totalEnergy * electRate;
                demand.regions[key].electricityDemand.push(elecDemand);

                // Per working-age adult metrics (Peters-informed)
                const gdpPerWorking = (currentState.gdp * 1e12) / working;  // $ per person
                const elecPerWorking = (elecDemand * 1e9) / working;        // kWh per person
                demand.regions[key].gdpPerWorking.push(gdpPerWorking);
                demand.regions[key].electricityPerWorking.push(elecPerWorking);

                // Accumulate globals
                globalGdp += currentState.gdp;
                globalElec += elecDemand;
                globalWorking += working;
            }

            // Store global aggregates
            demand.global.gdp.push(globalGdp);
            demand.global.electricityDemand.push(globalElec);
            demand.global.gdpPerWorking.push((globalGdp * 1e12) / globalWorking);
            demand.global.electricityPerWorking.push((globalElec * 1e9) / globalWorking);

            // Track initial for doubling calculation
            if (i === 0) {
                initialGlobalElec = globalElec;
            }

            // Find doubling year
            if (demand.metrics.demandDoubling === null && globalElec >= initialGlobalElec * 2) {
                demand.metrics.demandDoubling = year;
            }
        }

        // Calculate metrics
        const idx2050 = years.indexOf(2050);
        if (idx2050 !== -1) {
            demand.metrics.elec2050 = demand.global.electricityDemand[idx2050];

            // Asia-Pacific share (China + ~60% of EM as proxy)
            const asiaElec = demand.regions.china.electricityDemand[idx2050] +
                demand.regions.em.electricityDemand[idx2050] * 0.6;
            demand.metrics.asiaShare2050 = asiaElec / demand.global.electricityDemand[idx2050];
        }

        return demand;
    }

    // =============================================================================
    // DISPATCH - Merit order source allocation
    // =============================================================================

    /**
     * Calculate generation capacity (GW) available for each source
     * Tracks installed capacity with growth rates
     *
     * @param {number} year - Simulation year
     * @param {number} solarGrowth - Solar capacity growth rate
     * @returns {Object} Capacity in GW for each source
     */
    function getCapacities(year, solarGrowth) {
        const t = year - 2025;
        return {
            solar: energySources.solar.capacity2025 * Math.pow(1 + solarGrowth, t),
            wind: energySources.wind.capacity2025 * Math.pow(1 + energySources.wind.growthRate, t),
            gas: 2500 * Math.pow(1 + 0.01, t),       // ~2500 GW global gas capacity, slow growth
            coal: 2100 * Math.pow(1 - 0.02, t),     // ~2100 GW global coal, declining
            nuclear: energySources.nuclear.capacity2025 * Math.pow(1 + energySources.nuclear.growthRate, t),
            battery: energySources.battery.capacity2025 * Math.pow(1 + energySources.battery.growthRate, t) / 1000 // GWh → GW (4h storage)
        };
    }

    /**
     * Merit order dispatch - allocates demand to cheapest sources first
     * Respects capacity constraints and penetration limits
     *
     * @param {number} demandTWh - Total electricity demand in TWh
     * @param {Object} lcoes - LCOE for each source ($/MWh)
     * @param {Object} capacities - Installed capacity (GW) for each source
     * @returns {Object} Generation (TWh) by source, plus grid intensity
     */
    function dispatch(demandTWh, lcoes, capacities) {
        const hoursPerYear = 8760;
        const result = {
            solar: 0,
            wind: 0,
            gas: 0,
            coal: 0,
            nuclear: 0,
            solarPlusBattery: 0,
            total: 0
        };

        // Calculate max generation (TWh) each source can provide
        const maxGen = {
            solar: capacities.solar * dispatchParams.solar.capacityFactor * hoursPerYear / 1000,
            wind: capacities.wind * dispatchParams.wind.capacityFactor * hoursPerYear / 1000,
            gas: capacities.gas * dispatchParams.gas.capacityFactor * hoursPerYear / 1000,
            coal: capacities.coal * dispatchParams.coal.capacityFactor * hoursPerYear / 1000,
            nuclear: capacities.nuclear * dispatchParams.nuclear.capacityFactor * hoursPerYear / 1000
        };

        // Sort sources by LCOE (merit order)
        const sources = [
            { name: 'nuclear', lcoe: lcoes.nuclear, max: maxGen.nuclear, carbonIntensity: 0, maxPen: dispatchParams.nuclear.maxPenetration },
            { name: 'solar', lcoe: lcoes.solar, max: maxGen.solar, carbonIntensity: 0, maxPen: dispatchParams.solar.maxPenetration },
            { name: 'wind', lcoe: lcoes.wind, max: maxGen.wind, carbonIntensity: 0, maxPen: dispatchParams.wind.maxPenetration },
            { name: 'gas', lcoe: lcoes.gas, max: maxGen.gas, carbonIntensity: energySources.gas.carbonIntensity, maxPen: 1.0 },
            { name: 'coal', lcoe: lcoes.coal, max: maxGen.coal, carbonIntensity: energySources.coal.carbonIntensity, maxPen: 1.0 }
        ];

        sources.sort((a, b) => a.lcoe - b.lcoe);

        // Dispatch in merit order
        let remaining = demandTWh;
        let totalVRE = 0; // Variable renewable (solar + wind)
        const maxVREShare = Math.max(
            dispatchParams.solar.maxPenetration,
            dispatchParams.solarPlusBattery.maxPenetration * (capacities.battery > 50 ? 1 : 0.5)
        );

        for (const source of sources) {
            if (remaining <= 0) break;

            // Calculate penetration limit
            let maxPenetration = source.maxPen;

            // VRE sources share a combined penetration limit
            if (source.name === 'solar' || source.name === 'wind') {
                const remainingVRERoom = maxVREShare * demandTWh - totalVRE;
                maxPenetration = Math.min(maxPenetration, remainingVRERoom / demandTWh);
            }

            // Calculate how much this source can provide
            const maxByPenetration = maxPenetration * demandTWh;
            const maxByCapacity = source.max;
            const allocation = Math.min(remaining, maxByCapacity, maxByPenetration);

            if (allocation > 0) {
                result[source.name] = allocation;
                remaining -= allocation;

                if (source.name === 'solar' || source.name === 'wind') {
                    totalVRE += allocation;
                }
            }
        }

        // If demand not met (shouldn't happen with fossil backup), log warning
        if (remaining > 0.1 && !config.quiet) {
            console.warn(`Dispatch shortfall: ${remaining.toFixed(1)} TWh unmet`);
        }

        result.total = demandTWh - remaining;

        // Calculate grid carbon intensity (kg CO₂/MWh)
        const totalEmissions = result.gas * energySources.gas.carbonIntensity +
                               result.coal * energySources.coal.carbonIntensity;
        result.gridIntensity = result.total > 0 ? totalEmissions / result.total : 0;

        // Track solar+battery as the solar that's firm (backed by storage)
        // This is for display purposes; actual dispatch uses solar directly
        const firmSolarFraction = Math.min(1, capacities.battery / (capacities.solar * 0.5));
        result.solarPlusBattery = result.solar * firmSolarFraction;

        return result;
    }

    // =============================================================================
    // CLIMATE - Emissions and damage calculations
    // =============================================================================

    /**
     * Calculate total CO₂ emissions from dispatch and non-electric sectors
     *
     * @param {Object} dispatchResult - Generation (TWh) by source from dispatch()
     * @param {number} electrificationRate - Fraction of useful energy from electricity
     * @returns {Object} Emissions breakdown and total (Gt CO₂)
     */
    function calculateEmissions(dispatchResult, electrificationRate) {
        // Electricity emissions (Gt CO₂)
        const electricityEmissions = (
            dispatchResult.gas * energySources.gas.carbonIntensity +
            dispatchResult.coal * energySources.coal.carbonIntensity
        ) / 1e6; // kg → Gt

        // Non-electricity emissions decline with electrification
        // As electrification increases, transport/industry/heating shift to grid
        const nonElecBaseline = climateParams.nonElecEmissions2025;
        const electrificationGain = electrificationRate - 0.40; // Above 2025 baseline
        const nonElecReduction = Math.max(0, electrificationGain * 2.0); // 2 Gt reduction per 10% electrification
        const nonElecEmissions = Math.max(5, nonElecBaseline - nonElecReduction * nonElecBaseline);

        return {
            electricity: electricityEmissions,
            nonElectricity: nonElecEmissions,
            total: electricityEmissions + nonElecEmissions
        };
    }

    /**
     * Update climate state based on cumulative emissions
     *
     * @param {number} cumulativeEmissions - Total Gt CO₂ emitted since preindustrial
     * @param {number} previousTemp - Temperature from previous year (for lag)
     * @param {number} climSensitivity - Climate sensitivity (°C per CO₂ doubling)
     * @returns {Object} Updated CO₂ ppm and temperature
     */
    function updateClimate(cumulativeEmissions, previousTemp, climSensitivity) {
        // Calculate atmospheric CO₂
        const atmosphericCO2 = cumulativeEmissions * climateParams.airborneraction * climateParams.ppmPerGt;
        const co2ppm = climateParams.preindustrialCO2 + atmosphericCO2;

        // Equilibrium temperature from radiative forcing
        // T = S × log₂(CO₂/280)
        const equilibriumTemp = climSensitivity * Math.log2(co2ppm / climateParams.preindustrialCO2);

        // Temperature lags behind equilibrium (ocean thermal inertia)
        // Simple exponential approach: T(t) = T(t-1) + (T_eq - T(t-1)) / lag
        const lagFactor = 1 / climateParams.temperatureLag;
        const temperature = previousTemp + (equilibriumTemp - previousTemp) * lagFactor;

        return {
            co2ppm,
            equilibriumTemp,
            temperature
        };
    }

    /**
     * Calculate climate damages as fraction of GDP
     * Uses DICE-2023 quadratic damage function with regional variation
     *
     * @param {number} temperature - °C above preindustrial
     * @param {string} region - Region key (oecd, china, em, row)
     * @returns {number} Damage as fraction of GDP (0-0.30)
     */
    function climateDamages(temperature, region) {
        // Base quadratic damage: D = a × T²
        let damage = climateParams.damageCoeff * Math.pow(temperature, 2);

        // Regional multiplier
        const regionalMult = climateParams.regionalDamage[region] || 1.0;
        damage *= regionalMult;

        // Tipping point multiplier above threshold
        if (temperature > climateParams.tippingThreshold) {
            damage *= climateParams.tippingMultiplier;
        }

        // Cap damages (Weitzman bounded utility)
        return Math.min(damage, climateParams.maxDamage);
    }

    /**
     * Export demographics data as CSV
     */
    function exportDemographicsCSV(demographicsData) {
        const { years, regions, global } = demographicsData;
        let csv = 'Year,Region,Population,Young,Working,Old,TFR,Dependency\n';

        for (let i = 0; i < years.length; i++) {
            const year = years[i];

            for (const [key, data] of Object.entries(regions)) {
                csv += `${year},${demographics[key].name},${data.population[i].toFixed(0)},${data.young[i].toFixed(0)},${data.working[i].toFixed(0)},${data.old[i].toFixed(0)},${data.fertility[i].toFixed(2)},${(data.dependency[i] * 100).toFixed(1)}%\n`;
            }

            csv += `${year},Global,${global.population[i].toFixed(0)},${global.young[i].toFixed(0)},${global.working[i].toFixed(0)},${global.old[i].toFixed(0)},,${(global.dependency[i] * 100).toFixed(1)}%\n`;
        }

        return csv;
    }

    // =============================================================================
    // SIMULATION ENGINE
    // =============================================================================

    function runSimulation(params = {}) {
        const carbonPrice = params.carbonPrice ?? 50;
        const solarAlpha = params.solarAlpha ?? 0.36;  // Farmer/Naam calibrated
        const solarGrowth = params.solarGrowth ?? 0.25;
        const electrificationTarget = params.electrificationTarget ?? 0.65;
        const efficiencyMultiplier = params.efficiencyMultiplier ?? 1.0;
        const climSensitivity = params.climSensitivity ?? climateParams.climSensitivity;

        const years = [];
        const results = {
            solar: [],
            wind: [],
            gas: [],
            coal: [],
            nuclear: [],
            battery: [],
            solarPlusBattery: []
        };

        // Track cumulative extraction for fossil fuels
        let gasExtracted = 0;
        let coalExtracted = 0;

        // Store LCOEs for dispatch (need full arrays first)
        const lcoeArrays = { solar: [], wind: [], gas: [], coal: [], nuclear: [] };

        for (let year = 2025; year <= 2100; year++) {
            const t = year - 2025;
            years.push(year);

            // Solar: learning curve with configurable parameters
            const solarCapacity = energySources.solar.capacity2025 * Math.pow(1 + solarGrowth, t);
            const solarCumulative = solarCapacity / energySources.solar.capacity2025;
            const solarLCOE = learningCurve(energySources.solar.cost0, solarCumulative, solarAlpha);
            results.solar.push(solarLCOE);
            lcoeArrays.solar.push(solarLCOE);

            // Wind: learning curve
            const windCapacity = energySources.wind.capacity2025 * Math.pow(1 + energySources.wind.growthRate, t);
            const windCumulative = windCapacity / energySources.wind.capacity2025;
            const windLCOE = learningCurve(energySources.wind.cost0, windCumulative, energySources.wind.alpha);
            results.wind.push(windLCOE);
            lcoeArrays.wind.push(windLCOE);

            // Gas: EROEI depletion + carbon price
            gasExtracted += energySources.gas.extractionRate;
            const gasDepletion = depletion(
                energySources.gas.reserves,
                gasExtracted,
                energySources.gas.eroei0
            );
            // Cost rises as EROEI falls (need more energy input per output)
            const gasBaseCost = energySources.gas.cost0 * (energySources.gas.eroei0 / gasDepletion.eroei);
            const gasCarbonCost = (energySources.gas.carbonIntensity / 1000) * carbonPrice;
            const gasLCOE = gasBaseCost + gasCarbonCost;
            results.gas.push(gasLCOE);
            lcoeArrays.gas.push(gasLCOE);

            // Coal: EROEI depletion + carbon price
            coalExtracted += energySources.coal.extractionRate;
            const coalDepletion = depletion(
                energySources.coal.reserves,
                coalExtracted,
                energySources.coal.eroei0
            );
            const coalBaseCost = energySources.coal.cost0 * (energySources.coal.eroei0 / coalDepletion.eroei);
            const coalCarbonCost = (energySources.coal.carbonIntensity / 1000) * carbonPrice;
            const coalLCOE = coalBaseCost + coalCarbonCost;
            results.coal.push(coalLCOE);
            lcoeArrays.coal.push(coalLCOE);

            // Nuclear: essentially flat (no learning in current environment)
            const nuclearCapacity = energySources.nuclear.capacity2025 * Math.pow(1 + energySources.nuclear.growthRate, t);
            const nuclearCumulative = nuclearCapacity / energySources.nuclear.capacity2025;
            const nuclearLCOE = learningCurve(energySources.nuclear.cost0, nuclearCumulative, energySources.nuclear.alpha);
            results.nuclear.push(nuclearLCOE);
            lcoeArrays.nuclear.push(nuclearLCOE);

            // Battery: learning curve (cost per kWh)
            const batteryCapacity = energySources.battery.capacity2025 * Math.pow(1 + energySources.battery.growthRate, t);
            const batteryCumulative = batteryCapacity / energySources.battery.capacity2025;
            const batteryCost = learningCurve(energySources.battery.cost0, batteryCumulative, energySources.battery.alpha);
            results.battery.push(batteryCost);

            // Solar + Battery: combined cost for dispatchable clean energy
            // Assume 4 hours of storage needed, battery cycles 365 times/year for 15 years
            const batteryLCOE = (batteryCost * 4) / (365 * 15); // $/kWh storage → $/MWh contribution
            results.solarPlusBattery.push(solarLCOE + batteryLCOE * 1000); // Convert to $/MWh
        }

        // Run demographics simulation
        const demographicsData = runDemographics();

        // Run demand model
        const demandData = runDemandModel(demographicsData, {
            electrificationTarget,
            efficiencyMultiplier
        });

        // =============================================================================
        // CLIMATE MODULE - Dispatch, emissions, and damages
        // =============================================================================

        // Initialize climate tracking
        const climate = {
            emissions: [],              // Annual Gt CO₂
            electricityEmissions: [],   // Gt from electricity
            nonElecEmissions: [],       // Gt from non-electricity
            cumulative: [],             // Cumulative Gt CO₂
            co2ppm: [],                 // Atmospheric CO₂ concentration
            temperature: [],            // °C above preindustrial
            globalDamages: [],          // % GDP
            regionalDamages: { oecd: [], china: [], em: [], row: [] },
            netGdp: { global: [], oecd: [], china: [], em: [], row: [] }
        };

        // Dispatch results
        const dispatchData = {
            solar: [],
            wind: [],
            gas: [],
            coal: [],
            nuclear: [],
            gridIntensity: []
        };

        // Climate state variables
        let cumulativeEmissions = climateParams.cumulativeCO2_2025;
        let currentTemp = climateParams.currentTemp;
        let peakEmissionsYear = null;
        let peakEmissionsValue = 0;

        // Run climate simulation year by year
        for (let i = 0; i < years.length; i++) {
            const year = years[i];

            // Get LCOEs for this year
            const lcoes = {
                solar: lcoeArrays.solar[i],
                wind: lcoeArrays.wind[i],
                gas: lcoeArrays.gas[i],
                coal: lcoeArrays.coal[i],
                nuclear: lcoeArrays.nuclear[i]
            };

            // Get capacities
            const capacities = getCapacities(year, solarGrowth);

            // Get electricity demand
            const demandTWh = demandData.global.electricityDemand[i];

            // Dispatch sources to meet demand
            const dispatchResult = dispatch(demandTWh, lcoes, capacities);

            // Store dispatch results
            dispatchData.solar.push(dispatchResult.solar);
            dispatchData.wind.push(dispatchResult.wind);
            dispatchData.gas.push(dispatchResult.gas);
            dispatchData.coal.push(dispatchResult.coal);
            dispatchData.nuclear.push(dispatchResult.nuclear);
            dispatchData.gridIntensity.push(dispatchResult.gridIntensity);

            // Calculate emissions
            const electrificationRate = demandData.global.electrificationRate[i];
            const emissionsResult = calculateEmissions(dispatchResult, electrificationRate);

            climate.emissions.push(emissionsResult.total);
            climate.electricityEmissions.push(emissionsResult.electricity);
            climate.nonElecEmissions.push(emissionsResult.nonElectricity);

            // Track peak emissions
            if (emissionsResult.total > peakEmissionsValue) {
                peakEmissionsValue = emissionsResult.total;
                peakEmissionsYear = year;
            }

            // Update cumulative emissions
            cumulativeEmissions += emissionsResult.total;
            climate.cumulative.push(cumulativeEmissions);

            // Update climate state
            const climateState = updateClimate(cumulativeEmissions, currentTemp, climSensitivity);
            currentTemp = climateState.temperature;

            climate.co2ppm.push(climateState.co2ppm);
            climate.temperature.push(climateState.temperature);

            // Calculate damages by region
            let globalGrosGdp = 0;
            let globalNetGdp = 0;

            for (const region of ['oecd', 'china', 'em', 'row']) {
                const damage = climateDamages(currentTemp, region);
                climate.regionalDamages[region].push(damage * 100); // Store as percentage

                const grossGdp = demandData.regions[region].gdp[i];
                const netGdp = grossGdp * (1 - damage);
                climate.netGdp[region].push(netGdp);

                globalGrosGdp += grossGdp;
                globalNetGdp += netGdp;
            }

            // Global average damage
            const globalDamage = 1 - (globalNetGdp / globalGrosGdp);
            climate.globalDamages.push(globalDamage * 100); // Store as percentage
            climate.netGdp.global.push(globalNetGdp);
        }

        // Store climate metrics
        climate.metrics = {
            peakEmissionsYear,
            peakEmissionsValue,
            warming2100: climate.temperature[climate.temperature.length - 1],
            damages2075: climate.globalDamages[years.indexOf(2075)],
            gridIntensity2025: dispatchData.gridIntensity[0]
        };

        return {
            years,
            results,
            demographics: demographicsData,
            demand: demandData,
            climate,
            dispatch: dispatchData
        };
    }

    function findCrossovers(years, results) {
        const crossovers = [];

        // Solar crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.solar[i] < results.gas[i] && results.solar[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Solar LCOE falls below Gas',
                    detail: `Solar: $${results.solar[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Solar+Battery crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.solarPlusBattery[i] < results.gas[i] && results.solarPlusBattery[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Solar+Battery beats Gas (dispatchable clean)',
                    detail: `Solar+Batt: $${results.solarPlusBattery[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Coal becomes uneconomic (more expensive than cheapest clean)
        for (let i = 1; i < years.length; i++) {
            const cheapestClean = Math.min(results.solar[i], results.wind[i]);
            const cheapestCleanPrev = Math.min(results.solar[i-1], results.wind[i-1]);
            if (results.coal[i] > cheapestClean && results.coal[i-1] <= cheapestCleanPrev) {
                crossovers.push({
                    year: years[i],
                    event: 'Coal becomes more expensive than cheapest clean',
                    detail: `Coal: $${results.coal[i].toFixed(0)}/MWh vs Clean: $${cheapestClean.toFixed(0)}/MWh`
                });
                break;
            }
        }

        // Wind crosses gas
        for (let i = 1; i < years.length; i++) {
            if (results.wind[i] < results.gas[i] && results.wind[i-1] >= results.gas[i-1]) {
                crossovers.push({
                    year: years[i],
                    event: 'Wind LCOE falls below Gas',
                    detail: `Wind: $${results.wind[i].toFixed(0)}/MWh vs Gas: $${results.gas[i].toFixed(0)}/MWh`
                });
                break;
            }
        }

        return crossovers;
    }

    /**
     * Run a scenario and return key metrics as a flat object
     * Convenience wrapper for headless/programmatic use
     *
     * @param {Object} params - Same as runSimulation params (uses defaults if omitted)
     * @returns {Object} Key metrics: crossovers, peakEmissions, warming2100, elec2050, etc.
     */
    function runScenario(params = {}) {
        const mergedParams = { ...defaults, ...params };
        const simData = runSimulation(mergedParams);
        const { years, results, demographics, demand, climate, dispatch } = simData;
        const crossovers = findCrossovers(years, results);
        const derived = computeDerivedSeries(simData);

        const idx2050 = years.indexOf(2050);
        const idx2075 = years.indexOf(2075);
        const idx2100 = years.length - 1;

        // Find regional crossovers
        const chinaElecCrossesOECD = query.crossover(simData,
            'demand.regions.china.electricityDemand',
            'demand.regions.oecd.electricityDemand'
        );
        const emElecCrossesChina = query.crossover(simData,
            'demand.regions.em.electricityDemand',
            'demand.regions.china.electricityDemand'
        );

        // Find per-capita crossovers
        const chinaPerCapElec = derived.perCapita.electricity.china;
        const oecdPerCapElec = derived.perCapita.electricity.oecd;
        let chinaPerCapCrossesOECD = null;
        for (let i = 1; i < years.length; i++) {
            if (chinaPerCapElec[i] > oecdPerCapElec[i] && chinaPerCapElec[i - 1] <= oecdPerCapElec[i - 1]) {
                chinaPerCapCrossesOECD = years[i];
                break;
            }
        }

        // Grid intensity thresholds
        const gridBelow200 = query.gridIntensityBelow(simData, 200);
        const gridBelow100 = query.gridIntensityBelow(simData, 100);
        const gridBelow50 = query.gridIntensityBelow(simData, 50);

        return {
            // Input parameters used
            params: mergedParams,

            // Energy crossovers (LCOE)
            solarCrossesGas: crossovers.find(c => c.event.includes('Solar LCOE'))?.year ?? null,
            solarBatteryCrossesGas: crossovers.find(c => c.event.includes('Solar+Battery'))?.year ?? null,
            coalUneconomic: crossovers.find(c => c.event.includes('Coal'))?.year ?? null,
            windCrossesGas: crossovers.find(c => c.event.includes('Wind LCOE'))?.year ?? null,

            // Regional electricity crossovers
            chinaElecCrossesOECD: chinaElecCrossesOECD?.year ?? null,
            emElecCrossesChina: emElecCrossesChina?.year ?? null,

            // Per-capita crossovers
            chinaPerCapElecCrossesOECD: chinaPerCapCrossesOECD,

            // Grid intensity thresholds (year when grid falls below X kg CO₂/MWh)
            gridBelow200: gridBelow200,
            gridBelow100: gridBelow100,
            gridBelow50: gridBelow50,

            // Climate metrics
            peakEmissionsYear: climate.metrics.peakEmissionsYear,
            peakEmissionsGt: climate.metrics.peakEmissionsValue,
            warming2100: climate.metrics.warming2100,               // °C
            damages2075: climate.metrics.damages2075,               // % GDP
            damages2100: climate.globalDamages[idx2100],            // % GDP
            gridIntensity2025: climate.metrics.gridIntensity2025,   // kg CO₂/MWh
            gridIntensity2050: dispatch.gridIntensity[idx2050],     // kg CO₂/MWh
            gridIntensity2100: dispatch.gridIntensity[idx2100],     // kg CO₂/MWh
            emissions2025: climate.emissions[0],                    // Gt CO₂
            emissions2050: climate.emissions[idx2050],              // Gt CO₂
            emissions2100: climate.emissions[idx2100],              // Gt CO₂

            // Demand metrics
            elec2025: demand.global.electricityDemand[0],           // TWh
            elec2050: demand.global.electricityDemand[idx2050],     // TWh
            elec2100: demand.global.electricityDemand[idx2100],     // TWh
            electrification2050: demand.global.electrificationRate[idx2050], // fraction

            // Per-capita metrics (kWh/person)
            elecPerCapita2025: derived.global.electricityPerCapita[0],
            elecPerCapita2050: derived.global.electricityPerCapita[idx2050],
            elecPerCapita2100: derived.global.electricityPerCapita[idx2100],

            // Regional per-capita electricity 2050 (kWh/person)
            elecPerCapita2050_oecd: derived.perCapita.electricity.oecd[idx2050],
            elecPerCapita2050_china: derived.perCapita.electricity.china[idx2050],
            elecPerCapita2050_em: derived.perCapita.electricity.em[idx2050],
            elecPerCapita2050_row: derived.perCapita.electricity.row[idx2050],

            // Demographics metrics
            popPeakYear: findPopulationPeak(demographics.global.population, demographics.years).year,
            pop2100: demographics.global.population[idx2100],
            dependency2075: demographics.global.dependency[idx2075],

            // Derived series (for further analysis)
            derived,

            // Full data (if needed for deeper analysis)
            _fullData: simData
        };
    }

    /**
     * Export full simulation data as JSON
     * @param {Object} params - Same as runSimulation params
     * @returns {string} JSON string of full simulation results
     */
    function exportJSON(params = {}) {
        const mergedParams = { ...defaults, ...params };
        const data = runSimulation(mergedParams);
        const crossovers = findCrossovers(data.years, data.results);

        return JSON.stringify({
            params: mergedParams,
            years: data.years,
            lcoe: data.results,
            demographics: {
                years: data.demographics.years,
                global: data.demographics.global,
                regions: data.demographics.regions
            },
            demand: {
                global: data.demand.global,
                regions: data.demand.regions,
                metrics: data.demand.metrics
            },
            climate: data.climate,
            dispatch: data.dispatch,
            crossovers
        }, null, 2);
    }

    // =============================================================================
    // UNITS MAP - Canonical unit definitions
    // =============================================================================

    /**
     * Units map for all simulation outputs
     * Use energySim.units to check units for any series
     */
    const units = {
        // Energy costs
        lcoe: { unit: '$/MWh', description: 'Levelized cost of energy' },
        batteryCost: { unit: '$/kWh', description: 'Battery storage cost' },

        // Electricity
        electricityDemand: { unit: 'TWh', description: 'Annual electricity demand' },
        electricityPerWorking: { unit: 'kWh/person', description: 'Electricity per working-age adult' },
        electricityPerCapita: { unit: 'kWh/person', description: 'Electricity per capita' },
        generation: { unit: 'TWh', description: 'Electricity generation by source' },

        // GDP
        gdp: { unit: '$ trillions', description: 'Regional GDP' },
        gdpPerWorking: { unit: '$/person', description: 'GDP per working-age adult' },
        gdpPerCapita: { unit: '$/person', description: 'GDP per capita' },

        // Population
        population: { unit: 'persons', description: 'Absolute population count' },

        // Climate
        emissions: { unit: 'Gt CO₂/year', description: 'Annual CO₂ emissions' },
        cumulative: { unit: 'Gt CO₂', description: 'Cumulative CO₂ since preindustrial' },
        gridIntensity: { unit: 'kg CO₂/MWh', description: 'Grid carbon intensity' },
        temperature: { unit: '°C', description: 'Temperature above preindustrial' },
        co2ppm: { unit: 'ppm', description: 'Atmospheric CO₂ concentration' },

        // Damages and rates
        damages: { unit: '% GDP', description: 'Climate damages as percent of GDP' },
        dependency: { unit: 'ratio', description: 'Old-age dependency ratio (65+/20-64)' },
        electrificationRate: { unit: 'fraction', description: 'Electricity share of useful energy' },
        energyIntensity: { unit: 'MWh/$1000 GDP', description: 'Energy intensity of economy' },
        fertility: { unit: 'TFR', description: 'Total fertility rate (children per woman)' }
    };

    // =============================================================================
    // QUERY HELPERS - Time series analysis utilities
    // =============================================================================

    /**
     * Get array from dot-notation path in simulation data
     * @param {Object} data - Simulation data object
     * @param {string} path - Dot-notation path (e.g., 'demand.regions.china.electricityDemand')
     * @returns {Array} The array at the specified path
     */
    function getSeriesFromPath(data, path) {
        const parts = path.split('.');
        let current = data;
        for (const part of parts) {
            if (current === undefined || current === null) return null;
            current = current[part];
        }
        return Array.isArray(current) ? current : null;
    }

    /**
     * Query helpers for time series analysis
     */
    const query = {
        /**
         * Find first year where condition is met
         * @param {Object} options
         * @param {Object} options.data - Simulation data (from runSimulation or runScenario._fullData)
         * @param {string} options.series - Dot-notation path to series
         * @param {string} [options.gt] - Path to series that must be less than main series
         * @param {string} [options.lt] - Path to series that must be greater than main series
         * @param {number} [options.above] - Threshold value that must be exceeded
         * @param {number} [options.below] - Threshold value that must not be exceeded
         * @returns {number|null} Year when condition first met, or null
         */
        firstYear(options) {
            const { data, series, gt, lt, above, below } = options;
            const years = data.years || data.demographics?.years;
            const mainSeries = getSeriesFromPath(data, series);

            if (!years || !mainSeries) return null;

            const compareSeries = gt ? getSeriesFromPath(data, gt) : lt ? getSeriesFromPath(data, lt) : null;

            for (let i = 0; i < years.length; i++) {
                const val = mainSeries[i];
                let conditionMet = true;

                if (gt && compareSeries) conditionMet = conditionMet && val > compareSeries[i];
                if (lt && compareSeries) conditionMet = conditionMet && val < compareSeries[i];
                if (above !== undefined) conditionMet = conditionMet && val > above;
                if (below !== undefined) conditionMet = conditionMet && val < below;

                if (conditionMet) return years[i];
            }
            return null;
        },

        /**
         * Find crossover year between two series
         * @param {Object} data - Simulation data
         * @param {string} series1 - Path to first series (the one crossing over)
         * @param {string} series2 - Path to second series (being crossed)
         * @returns {Object|null} { year, values: { series1, series2 } } or null
         */
        crossover(data, series1, series2) {
            const years = data.years || data.demographics?.years;
            const s1 = getSeriesFromPath(data, series1);
            const s2 = getSeriesFromPath(data, series2);

            if (!years || !s1 || !s2) return null;

            for (let i = 1; i < years.length; i++) {
                // series1 crosses above series2
                if (s1[i] > s2[i] && s1[i - 1] <= s2[i - 1]) {
                    return {
                        year: years[i],
                        direction: 'above',
                        values: { series1: s1[i], series2: s2[i] }
                    };
                }
                // series1 crosses below series2
                if (s1[i] < s2[i] && s1[i - 1] >= s2[i - 1]) {
                    return {
                        year: years[i],
                        direction: 'below',
                        values: { series1: s1[i], series2: s2[i] }
                    };
                }
            }
            return null;
        },

        /**
         * Get value at specific year
         * @param {Object} data - Simulation data
         * @param {string} series - Path to series
         * @param {number} year - Year to look up
         * @returns {number|null} Value at year or null
         */
        valueAt(data, series, year) {
            const years = data.years || data.demographics?.years;
            const s = getSeriesFromPath(data, series);
            if (!years || !s) return null;

            const idx = years.indexOf(year);
            return idx >= 0 ? s[idx] : null;
        },

        /**
         * Get per-capita series for a region
         * @param {Object} data - Simulation data
         * @param {string} region - Region key (oecd, china, em, row)
         * @param {string} metric - 'electricity' or 'gdp'
         * @returns {Array} Per-capita values
         */
        perCapita(data, region, metric = 'electricity') {
            const pop = getSeriesFromPath(data, `demographics.regions.${region}.population`);
            let values;

            if (metric === 'electricity') {
                values = getSeriesFromPath(data, `demand.regions.${region}.electricityDemand`);
                // Convert TWh to kWh: TWh × 1e9 / population
                return pop && values ? values.map((v, i) => (v * 1e9) / pop[i]) : null;
            } else if (metric === 'gdp') {
                values = getSeriesFromPath(data, `demand.regions.${region}.gdp`);
                // Convert $ trillions to $: $T × 1e12 / population
                return pop && values ? values.map((v, i) => (v * 1e12) / pop[i]) : null;
            }
            return null;
        },

        /**
         * Find year when grid intensity falls below threshold
         * @param {Object} data - Simulation data
         * @param {number} threshold - kg CO₂/MWh threshold (default: 100 for "clean grid")
         * @returns {number|null} Year when threshold crossed
         */
        gridIntensityBelow(data, threshold = 100) {
            return this.firstYear({
                data,
                series: 'dispatch.gridIntensity',
                below: threshold
            });
        },

        /**
         * Find all crossovers between regions for a metric
         * @param {Object} data - Simulation data
         * @param {string} metric - Path template with {region} placeholder
         * @param {string} region1 - First region
         * @param {string} region2 - Second region
         * @returns {Object|null} Crossover info or null
         */
        regionCrossover(data, metric, region1, region2) {
            const path1 = metric.replace('{region}', region1);
            const path2 = metric.replace('{region}', region2);
            return this.crossover(data, path1, path2);
        }
    };

    // =============================================================================
    // DERIVED SERIES - Pre-computed per-capita and other derived metrics
    // =============================================================================

    /**
     * Compute derived series (per-capita metrics, etc.)
     * @param {Object} simData - Output from runSimulation
     * @returns {Object} Derived series
     */
    function computeDerivedSeries(simData) {
        const { years, demographics, demand, climate, dispatch } = simData;
        const regions = ['oecd', 'china', 'em', 'row'];

        const derived = {
            years,
            perCapita: {
                electricity: {},  // kWh/person by region
                gdp: {}           // $/person by region
            },
            global: {
                electricityPerCapita: [],  // kWh/person
                gdpPerCapita: []           // $/person
            }
        };

        // Compute regional per-capita
        for (const region of regions) {
            const pop = demographics.regions[region].population;
            const elec = demand.regions[region].electricityDemand;
            const gdp = demand.regions[region].gdp;

            derived.perCapita.electricity[region] = elec.map((e, i) => (e * 1e9) / pop[i]);
            derived.perCapita.gdp[region] = gdp.map((g, i) => (g * 1e12) / pop[i]);
        }

        // Compute global per-capita
        for (let i = 0; i < years.length; i++) {
            const globalPop = demographics.global.population[i];
            const globalElec = demand.global.electricityDemand[i];
            const globalGdp = demand.global.gdp[i];

            derived.global.electricityPerCapita.push((globalElec * 1e9) / globalPop);
            derived.global.gdpPerCapita.push((globalGdp * 1e12) / globalPop);
        }

        return derived;
    }

    // =============================================================================
    // VISUALIZATION (Browser-only)
    // =============================================================================
    //
    // Everything above this line is pure JS with no DOM dependencies.
    // For headless use: call energySim.runSimulation(params) or energySim.runScenario(params)
    // directly without loading the DOM.
    //
    // The UI code below only runs in a browser environment.

    // Check for browser environment before initializing UI
    const isBrowser = typeof document !== 'undefined' && document.getElementById;

    let lcoeChart = null;
    let batteryChart = null;
    let populationChart = null;
    let dependencyChart = null;
    let demandChart = null;
    let gdpPerWorkerChart = null;
    let intensityChart = null;
    let generationChart = null;
    let emissionsChart = null;
    let temperatureChart = null;
    let damagesChart = null;
    let currentDemographicsData = null;
    let currentDemandData = null;
    let currentClimateData = null;
    let currentDispatchData = null;

    function updateCharts() {
        const carbonPrice = parseFloat(document.getElementById('carbon-price').value);
        const solarAlpha = parseFloat(document.getElementById('solar-alpha').value);
        const solarGrowth = parseFloat(document.getElementById('solar-growth').value) / 100;
        const electrificationTarget = parseFloat(document.getElementById('electrification-target').value) / 100;
        const efficiencyMultiplier = parseFloat(document.getElementById('efficiency-mult').value);
        const climSensitivity = parseFloat(document.getElementById('clim-sensitivity').value);

        document.getElementById('carbon-price-value').textContent = `$${carbonPrice}`;
        document.getElementById('solar-alpha-value').textContent = solarAlpha.toFixed(2);
        document.getElementById('solar-growth-value').textContent = `${(solarGrowth * 100).toFixed(0)}%`;
        document.getElementById('electrification-target-value').textContent = `${(electrificationTarget * 100).toFixed(0)}%`;
        document.getElementById('efficiency-mult-value').textContent = `${efficiencyMultiplier.toFixed(2)}×`;
        document.getElementById('clim-sensitivity-value').textContent = `${climSensitivity.toFixed(1)}°C`;

        const { years, results, demographics: demographicsData, demand: demandData, climate: climateData, dispatch: dispatchData } = runSimulation({
            carbonPrice, solarAlpha, solarGrowth, electrificationTarget, efficiencyMultiplier, climSensitivity
        });
        currentDemographicsData = demographicsData;
        currentDemandData = demandData;
        currentClimateData = climateData;
        currentDispatchData = dispatchData;
        const crossovers = findCrossovers(years, results);

        // Update metrics
        const solarGasCross = crossovers.find(c => c.event.includes('Solar LCOE'));
        document.getElementById('solar-gas-cross').textContent = solarGasCross ? solarGasCross.year : 'Already';

        const solarBattGasCross = crossovers.find(c => c.event.includes('Solar+Battery'));
        document.getElementById('solar-battery-gas-cross').textContent = solarBattGasCross ? solarBattGasCross.year : 'Already';

        const coalUneconomic = crossovers.find(c => c.event.includes('Coal'));
        document.getElementById('coal-uneconomic').textContent = coalUneconomic ? coalUneconomic.year : 'Already';

        const battery2035Index = years.indexOf(2035);
        document.getElementById('battery-2035').textContent = `$${results.battery[battery2035Index].toFixed(0)}`;

        // Update demographic metrics
        const popPeak = findPopulationPeak(demographicsData.global.population, demographicsData.years);
        document.getElementById('pop-peak').textContent = popPeak.year;

        const dep2075Index = demographicsData.years.indexOf(2075);
        const dep2025Index = 0;
        const dep2025 = (demographicsData.global.dependency[dep2025Index] * 100).toFixed(0);
        const dep2075 = (demographicsData.global.dependency[dep2075Index] * 100).toFixed(0);
        document.getElementById('dependency-2075').textContent = `${dep2025}% → ${dep2075}%`;

        // Update demand metrics
        const idx2050 = demographicsData.years.indexOf(2050);
        document.getElementById('elec-2050').textContent = demandData.metrics.elec2050 ?
            `${(demandData.metrics.elec2050 / 1000).toFixed(1)}K` : '--';
        document.getElementById('electrification-2050').textContent = idx2050 !== -1 ?
            `${(demandData.global.electrificationRate[idx2050] * 100).toFixed(0)}%` : '--';
        document.getElementById('kwh-worker-2050').textContent = idx2050 !== -1 ?
            `${(demandData.global.electricityPerWorking[idx2050] / 1000).toFixed(1)}K` : '--';

        // Update climate metrics
        document.getElementById('grid-intensity-2025').textContent =
            `${climateData.metrics.gridIntensity2025.toFixed(0)}`;
        document.getElementById('peak-emissions').textContent =
            climateData.metrics.peakEmissionsYear || 'N/A';
        document.getElementById('warming-2100').textContent =
            `${climateData.metrics.warming2100.toFixed(1)}°C`;
        document.getElementById('damages-2075').textContent =
            `${climateData.metrics.damages2075.toFixed(1)}%`;

        // Update crossover events
        const eventsHtml = crossovers.map(c => `
            <div class="insight-item">
                <span class="insight-year">${c.year}</span>: ${c.event}<br>
                <span style="color: #666; font-size: 13px;">${c.detail}</span>
            </div>
        `).join('');
        document.getElementById('crossover-events').innerHTML = eventsHtml || '<div class="insight-item">No crossovers detected in this scenario</div>';

        // Update era table
        const eras = ['2025-29', '2030-34', '2035-39', '2040-44', '2045-49', '2050-54', '2055-59', '2060-64', '2065-69', '2070-74', '2075-79', '2080-84', '2085-89', '2090-94', '2095-99'];
        const tbody = document.getElementById('era-tbody');
        tbody.innerHTML = '';

        for (let e = 0; e < eras.length; e++) {
            const startIdx = e * 5;
            const endIdx = Math.min(startIdx + 5, years.length);

            // Average over era (reusable for all arrays)
            const avg = (arr) => {
                let sum = 0;
                for (let i = startIdx; i < endIdx; i++) sum += arr[i];
                return sum / (endIdx - startIdx);
            };

            const row = document.createElement('tr');

            // Check if this era has a crossover
            const eraStart = 2025 + e * 5;
            const eraEnd = eraStart + 4;
            const hasCrossover = crossovers.some(c => c.year >= eraStart && c.year <= eraEnd);
            if (hasCrossover) row.classList.add('crossover-highlight');

            row.innerHTML = `
                <td>${eras[e]}</td>
                <td>$${avg(results.solar).toFixed(0)}</td>
                <td>$${avg(results.wind).toFixed(0)}</td>
                <td>$${avg(results.gas).toFixed(0)}</td>
                <td>$${avg(results.coal).toFixed(0)}</td>
                <td>$${avg(results.nuclear).toFixed(0)}</td>
                <td>$${avg(results.battery).toFixed(0)}/kWh</td>
                <td>$${avg(results.solarPlusBattery).toFixed(0)}</td>
                <td>${avg(climateData.emissions).toFixed(1)} Gt</td>
                <td>${avg(climateData.temperature).toFixed(1)}°C</td>
                <td>${avg(climateData.globalDamages).toFixed(1)}%</td>
            `;
            tbody.appendChild(row);
        }

        // LCOE Chart
        const lcoeCtx = document.getElementById('lcoe-chart').getContext('2d');

        if (lcoeChart) lcoeChart.destroy();

        lcoeChart = new Chart(lcoeCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Solar',
                        data: results.solar,
                        borderColor: energySources.solar.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Wind',
                        data: results.wind,
                        borderColor: energySources.wind.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Gas',
                        data: results.gas,
                        borderColor: energySources.gas.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Coal',
                        data: results.coal,
                        borderColor: energySources.coal.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Nuclear',
                        data: results.nuclear,
                        borderColor: energySources.nuclear.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Solar+Battery',
                        data: results.solarPlusBattery,
                        borderColor: '#ff006e',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: $${context.parsed.y.toFixed(0)}/MWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return '$' + value;
                            }
                        },
                        title: {
                            display: true,
                            text: '$/MWh',
                            color: '#888'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });

        // Custom legend
        const legendHtml = [
            { label: 'Solar', color: energySources.solar.color },
            { label: 'Wind', color: energySources.wind.color },
            { label: 'Gas', color: energySources.gas.color },
            { label: 'Coal', color: energySources.coal.color },
            { label: 'Nuclear', color: energySources.nuclear.color },
            { label: 'Solar+Battery', color: '#ff006e' }
        ].map(item => `
            <div class="legend-item">
                <div class="legend-color" style="background: ${item.color}"></div>
                ${item.label}
            </div>
        `).join('');
        document.getElementById('chart-legend').innerHTML = legendHtml;

        // Battery Chart
        const batteryCtx = document.getElementById('battery-chart').getContext('2d');

        if (batteryChart) batteryChart.destroy();

        batteryChart = new Chart(batteryCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [{
                    label: 'Battery $/kWh',
                    data: results.battery,
                    borderColor: energySources.battery.color,
                    backgroundColor: 'rgba(6, 214, 160, 0.1)',
                    fill: true,
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `$${context.parsed.y.toFixed(0)}/kWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return '$' + value;
                            }
                        },
                        title: {
                            display: true,
                            text: '$/kWh',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Population Chart (stacked area)
        const popCtx = document.getElementById('population-chart').getContext('2d');
        if (populationChart) populationChart.destroy();

        populationChart = new Chart(popCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'OECD',
                        data: demographicsData.regions.oecd.population.map(p => p / 1e9),
                        borderColor: demographics.oecd.color,
                        backgroundColor: demographics.oecd.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demographicsData.regions.china.population.map(p => p / 1e9),
                        borderColor: demographics.china.color,
                        backgroundColor: demographics.china.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demographicsData.regions.em.population.map(p => p / 1e9),
                        borderColor: demographics.em.color,
                        backgroundColor: demographics.em.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demographicsData.regions.row.population.map(p => p / 1e9),
                        borderColor: demographics.row.color,
                        backgroundColor: demographics.row.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}B`;
                            },
                            footer: function(items) {
                                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${total.toFixed(2)}B`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        stacked: true,
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + 'B';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Population (Billions)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Dependency Ratio Chart
        const depCtx = document.getElementById('dependency-chart').getContext('2d');
        if (dependencyChart) dependencyChart.destroy();

        dependencyChart = new Chart(depCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'Global',
                        data: demographicsData.global.dependency.map(d => d * 100),
                        borderColor: '#fff',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'OECD',
                        data: demographicsData.regions.oecd.dependency.map(d => d * 100),
                        borderColor: demographics.oecd.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demographicsData.regions.china.dependency.map(d => d * 100),
                        borderColor: demographics.china.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demographicsData.regions.em.dependency.map(d => d * 100),
                        borderColor: demographics.em.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demographicsData.regions.row.dependency.map(d => d * 100),
                        borderColor: demographics.row.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Old-Age Dependency Ratio (65+ / 20-64)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Electricity Demand Chart (stacked area)
        const demandCtx = document.getElementById('demand-chart').getContext('2d');
        if (demandChart) demandChart.destroy();

        demandChart = new Chart(demandCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'OECD',
                        data: demandData.regions.oecd.electricityDemand.map(d => d / 1000),
                        borderColor: demographics.oecd.color,
                        backgroundColor: demographics.oecd.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demandData.regions.china.electricityDemand.map(d => d / 1000),
                        borderColor: demographics.china.color,
                        backgroundColor: demographics.china.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demandData.regions.em.electricityDemand.map(d => d / 1000),
                        borderColor: demographics.em.color,
                        backgroundColor: demographics.em.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demandData.regions.row.electricityDemand.map(d => d / 1000),
                        borderColor: demographics.row.color,
                        backgroundColor: demographics.row.color + '40',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(0)}K TWh`;
                            },
                            footer: function(items) {
                                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${total.toFixed(0)}K TWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        stacked: true,
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + 'K';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Electricity Demand (1000s TWh)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // GDP per Working-Age Adult Chart
        const gdpCtx = document.getElementById('gdp-per-worker-chart').getContext('2d');
        if (gdpPerWorkerChart) gdpPerWorkerChart.destroy();

        gdpPerWorkerChart = new Chart(gdpCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'Global',
                        data: demandData.global.gdpPerWorking.map(g => g / 1000),
                        borderColor: '#fff',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'OECD',
                        data: demandData.regions.oecd.gdpPerWorking.map(g => g / 1000),
                        borderColor: demographics.oecd.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demandData.regions.china.gdpPerWorking.map(g => g / 1000),
                        borderColor: demographics.china.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demandData.regions.em.gdpPerWorking.map(g => g / 1000),
                        borderColor: demographics.em.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demandData.regions.row.gdpPerWorking.map(g => g / 1000),
                        borderColor: demographics.row.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: $${context.parsed.y.toFixed(0)}K`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return '$' + value + 'K';
                            }
                        },
                        title: {
                            display: true,
                            text: 'GDP per Working-Age Adult ($1000s)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Energy Intensity Chart
        const intensityCtx = document.getElementById('intensity-chart').getContext('2d');
        if (intensityChart) intensityChart.destroy();

        intensityChart = new Chart(intensityCtx, {
            type: 'line',
            data: {
                labels: demographicsData.years,
                datasets: [
                    {
                        label: 'OECD',
                        data: demandData.regions.oecd.energyIntensity,
                        borderColor: demographics.oecd.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: demandData.regions.china.energyIntensity,
                        borderColor: demographics.china.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: demandData.regions.em.energyIntensity,
                        borderColor: demographics.em.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: demandData.regions.row.energyIntensity,
                        borderColor: demographics.row.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(3)} MWh/$1000`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888'
                        },
                        title: {
                            display: true,
                            text: 'Energy Intensity (MWh per $1000 GDP)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Generation Mix Chart (stacked area)
        const genCtx = document.getElementById('generation-chart').getContext('2d');
        if (generationChart) generationChart.destroy();

        generationChart = new Chart(genCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Nuclear',
                        data: dispatchData.nuclear.map(d => d / 1000),
                        borderColor: energySources.nuclear.color,
                        backgroundColor: energySources.nuclear.color + '60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Solar',
                        data: dispatchData.solar.map(d => d / 1000),
                        borderColor: energySources.solar.color,
                        backgroundColor: energySources.solar.color + '60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Wind',
                        data: dispatchData.wind.map(d => d / 1000),
                        borderColor: energySources.wind.color,
                        backgroundColor: energySources.wind.color + '60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Gas',
                        data: dispatchData.gas.map(d => d / 1000),
                        borderColor: energySources.gas.color,
                        backgroundColor: energySources.gas.color + '60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Coal',
                        data: dispatchData.coal.map(d => d / 1000),
                        borderColor: energySources.coal.color,
                        backgroundColor: energySources.coal.color + '60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${(context.parsed.y * 1000).toFixed(0)} TWh`;
                            },
                            footer: function(items) {
                                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${(total * 1000).toFixed(0)} TWh`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        stacked: true,
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + 'K';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Generation (1000s TWh)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Emissions Chart (stacked area)
        const emissionsCtx = document.getElementById('emissions-chart').getContext('2d');
        if (emissionsChart) emissionsChart.destroy();

        emissionsChart = new Chart(emissionsCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Electricity',
                        data: climateData.electricityEmissions,
                        borderColor: '#f94144',
                        backgroundColor: '#f9414460',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Non-Electricity',
                        data: climateData.nonElecEmissions,
                        borderColor: '#90be6d',
                        backgroundColor: '#90be6d60',
                        fill: true,
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} Gt`;
                            },
                            footer: function(items) {
                                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${total.toFixed(1)} Gt CO₂`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        stacked: true,
                        grid: { color: '#333' },
                        ticks: { color: '#888' },
                        title: {
                            display: true,
                            text: 'Emissions (Gt CO₂/year)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Temperature Chart
        const tempCtx = document.getElementById('temperature-chart').getContext('2d');
        if (temperatureChart) temperatureChart.destroy();

        temperatureChart = new Chart(tempCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Temperature',
                        data: climateData.temperature,
                        borderColor: '#f94144',
                        backgroundColor: 'rgba(249, 65, 68, 0.1)',
                        fill: true,
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y.toFixed(2)}°C above preindustrial`;
                            }
                        }
                    },
                    annotation: {
                        annotations: {
                            line1_5: {
                                type: 'line',
                                yMin: 1.5,
                                yMax: 1.5,
                                borderColor: '#ffd60a',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: '1.5°C Paris target',
                                    position: 'start',
                                    color: '#ffd60a',
                                    backgroundColor: 'transparent'
                                }
                            },
                            line2: {
                                type: 'line',
                                yMin: 2.0,
                                yMax: 2.0,
                                borderColor: '#f77f00',
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: '2°C limit',
                                    position: 'start',
                                    color: '#f77f00',
                                    backgroundColor: 'transparent'
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + '°C';
                            }
                        },
                        min: 0,
                        title: {
                            display: true,
                            text: 'Temperature Rise (°C)',
                            color: '#888'
                        }
                    }
                }
            }
        });

        // Climate Damages Chart
        const damagesCtx = document.getElementById('damages-chart').getContext('2d');
        if (damagesChart) damagesChart.destroy();

        damagesChart = new Chart(damagesCtx, {
            type: 'line',
            data: {
                labels: years,
                datasets: [
                    {
                        label: 'Global',
                        data: climateData.globalDamages,
                        borderColor: '#fff',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'OECD',
                        data: climateData.regionalDamages.oecd,
                        borderColor: demographics.oecd.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'China',
                        data: climateData.regionalDamages.china,
                        borderColor: demographics.china.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Emerging Markets',
                        data: climateData.regionalDamages.em,
                        borderColor: demographics.em.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    },
                    {
                        label: 'Rest of World',
                        data: climateData.regionalDamages.row,
                        borderColor: demographics.row.color,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { color: '#888' }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}% GDP`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    },
                    y: {
                        grid: { color: '#333' },
                        ticks: {
                            color: '#888',
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Climate Damages (% GDP)',
                            color: '#888'
                        }
                    }
                }
            }
        });
    }

    // Initialize UI only in browser environment
    if (isBrowser) {
        // Event listeners
        document.getElementById('carbon-price').addEventListener('input', updateCharts);
        document.getElementById('solar-alpha').addEventListener('input', updateCharts);
        document.getElementById('solar-growth').addEventListener('input', updateCharts);
        document.getElementById('electrification-target').addEventListener('input', updateCharts);
        document.getElementById('efficiency-mult').addEventListener('input', updateCharts);
        document.getElementById('clim-sensitivity').addEventListener('input', updateCharts);

        // CSV Export
        document.getElementById('export-csv').addEventListener('click', function() {
            if (!currentDemographicsData) return;
            const csv = exportDemographicsCSV(currentDemographicsData);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'demographics_2025_2100.csv';
            a.click();
            URL.revokeObjectURL(url);
        });

        // JSON Export (full simulation data)
        document.getElementById('export-json').addEventListener('click', function() {
            // Get current slider values
            const params = {
                carbonPrice: parseFloat(document.getElementById('carbon-price').value),
                solarAlpha: parseFloat(document.getElementById('solar-alpha').value),
                solarGrowth: parseFloat(document.getElementById('solar-growth').value) / 100,
                electrificationTarget: parseFloat(document.getElementById('electrification-target').value) / 100,
                efficiencyMultiplier: parseFloat(document.getElementById('efficiency-mult').value),
                climSensitivity: parseFloat(document.getElementById('clim-sensitivity').value)
            };
            const json = exportJSON(params);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'energy_simulation.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Initial render
        updateCharts();
    }

    /**
     * Console API for programmatic access
     *
     * See energySim.units for canonical unit definitions.
     */
    window.energySim = {
        // Primitives
        compound,
        learningCurve,
        depletion,
        logistic,
        poissonShock,

        // Simulation (full runs)
        runSimulation,        // Full simulation, returns { years, results, demographics, demand, climate, dispatch }
        runScenario,          // Convenience wrapper, returns flat metrics object + derived series
        exportJSON,           // Export full run as JSON string

        // Query helpers (time series analysis)
        query,                // { firstYear, crossover, valueAt, perCapita, gridIntensityBelow, regionCrossover }
        computeDerivedSeries, // Compute per-capita and other derived metrics

        // Sub-models
        runDemographics,
        runDemandModel,
        findCrossovers,
        findPopulationPeak,
        exportDemographicsCSV,
        projectFertility,

        // Climate functions
        dispatch,             // Merit order dispatch
        getCapacities,        // GW capacity by year
        calculateEmissions,   // Returns { electricity, nonElectricity, total } in Gt CO₂
        updateClimate,        // Returns { co2ppm, equilibriumTemp, temperature }
        climateDamages,       // Returns damage fraction (0-0.30)

        // Parameters (read-only references)
        energySources,
        demographics,
        economicParams,
        demandParams,
        dispatchParams,
        climateParams,

        // Units map
        units,                // Canonical unit definitions for all series

        // Defaults and config
        defaults,             // Default slider values
        config,               // Runtime config (set config.quiet = true to suppress warnings)

        // Current UI data (reactive getters, reflect last updateCharts() call)
        get demographicsData() { return currentDemographicsData; },
        get demand() { return currentDemandData; },
        get climate() { return currentClimateData; },
        get dispatchData() { return currentDispatchData; }
    };

    if (!config.quiet) {
        console.log('Energy Simulation loaded. Access via window.energySim');
        console.log('Quick start:');
        console.log('  energySim.runScenario({ carbonPrice: 100 })  // Returns flat metrics + crossovers');
        console.log('  energySim.query.firstYear({ data, series, gt })  // Find crossover year');
        console.log('  energySim.units                              // See unit definitions');
        console.log('  energySim.config.quiet = true                // Suppress all console output');
    }
    </script>
</body>
</html>
